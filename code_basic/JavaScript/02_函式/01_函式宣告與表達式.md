# 函式宣告 (Declaration) 與 表達式 (Expression)

在 JavaScript 中，定義函式主要有兩種方式，它們在語法和**提升 (Hoisting)** 行為上有所不同。

## 1. 函式宣告 (Function Declaration)

這是最傳統、最常見的定義方式，使用 `function` 關鍵字開頭，並給予一個函式名稱。

```javascript
function sayHello(name) {
    return `Hello, ${name}!`;
}

console.log(sayHello("Alice"));
```

### 提升 (Hoisting) 特性

函式宣告**會被完整提升**。這意味著你可以在程式碼中宣告函式**之前**就呼叫它。

```javascript
greet(); // 這是合法的！輸出: Hi there!

function greet() {
    console.log("Hi there!");
}
```

這在組織程式碼時很有用，你可以把主要的邏輯放在上面，輔助的函式放在下面。

## 2. 函式表達式 (Function Expression)

函式表達式是將一個函式（通常是匿名的）賦值給一個變數。

```javascript
const add = function(a, b) {
    return a + b;
};

console.log(add(2, 3));
```

### 提升特性

函式表達式**不會被提升**。
雖然變數宣告 (如 `var`) 可能會被提升，但賦值操作不會。如果是用 `const` 或 `let` 宣告，則會受到 TDZ (暫時性死區) 的影響。

**你必須先定義，才能呼叫。**

```javascript
// bark(); // Error: Cannot access 'bark' before initialization

const bark = function() {
    console.log("Woof!");
};
```

## 3. 立即執行函式 (IIFE)

Immediately Invoked Function Expression。定義完馬上執行的函式，常用於建立一個獨立的作用域，避免汙染全域變數（在模組化普及前很常用）。

```javascript
(function() {
    let secret = "這是秘密";
    console.log("IIFE 執行中");
})();

// console.log(secret); // Error: secret is not defined
```

## 總結比較

| 特性 | 函式宣告 | 函式表達式 |
| :--- | :--- | :--- |
| **語法** | `function foo() {}` | `const foo = function() {}` |
| **提升** | ✅ (可先用後定義) | ❌ (必須先定義後使用) |
| **用途** | 通用，適合全域或模組頂層函式 | 回呼函式、閉包、物件方法、限制作用域 |
