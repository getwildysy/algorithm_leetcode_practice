# 箭頭函式 (Arrow Functions)

ES6 引入了箭頭函式 `=>`，它不僅提供了更簡潔的語法來定義函式，更重要的是它改變了 `this` 關鍵字的行為。

## 1. 基本語法

去掉 `function` 關鍵字，改用 `=>` 連結參數與函式主體。

```javascript
// 傳統函式表達式
const add = function(a, b) {
    return a + b;
};

// 箭頭函式
const addArrow = (a, b) => {
    return a + b;
};
```

## 2. 語法簡寫 (Syntactic Sugar)

箭頭函式在特定情況下可以寫得更簡潔：

### (1) 省略參數括號
如果只有**一個**參數，可以省略 `()`。

```javascript
const square = x => x * x;
// 等同於 (x) => { return x * x; }
```

### (2) 隱式回傳 (Implicit Return)
如果函式本體只有**一行表達式** (expression)，可以省略 `{}` 和 `return` 關鍵字。該表達式的結果會自動被回傳。

```javascript
const double = n => n * 2;

// 若回傳的是物件字面量，必須用小括號包起來，否則 {} 會被視為區塊
const getUser = id => ({ id: id, name: "User" });
```

## 3. 箭頭函式的 this (Lexical this)

這是箭頭函式與傳統函式最大的區別。

*   **傳統函式**：`this` 的值取決於**呼叫方式** (動態綁定)。
*   **箭頭函式**：沒有自己的 `this`。它會**繼承**定義時外層作用域 (Lexical Scope) 的 `this`。

### 範例比較

```javascript
const person = {
    name: "Alice",
    sayHi: function() {
        // 這裡的 this 指向 person 物件
        
        // 情況 A: 使用傳統函式作為 callback
        setTimeout(function() {
            // 傳統函式的 this 在 setTimeout 中通常指向 window (或 undefined)
            console.log("Traditional:", this.name); 
        }, 100);

        // 情況 B: 使用箭頭函式
        setTimeout(() => {
            // 箭頭函式繼承了 sayHi 的 this，也就是 person
            console.log("Arrow:", this.name); // 輸出: Alice
        }, 100);
    }
};

person.sayHi();
```

## 4. 什麼時候**不該用**箭頭函式？

雖然箭頭函式很方便，但在某些需要動態 `this` 的場合不適合使用：

1.  **物件的方法 (Object Methods)**：
    ```javascript
    const cat = {
        count: 0,
        jump: () => {
            this.count++; // 錯誤！這裡的 this 不會指向 cat
        }
    };
    ```
2.  **事件監聽器 (Event Handlers)**：當你需要 `this` 指向觸發事件的 DOM 元素時。
    ```javascript
    button.addEventListener('click', () => {
        // this 會指向 window，而不是 button
    });
    ```
3.  **建構函式 (Constructors)**：箭頭函式不能用作建構函式，不能使用 `new`。
