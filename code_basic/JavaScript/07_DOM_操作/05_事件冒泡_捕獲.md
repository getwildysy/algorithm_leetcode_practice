# DOM 事件：冒泡 (Bubbling) 與 捕獲 (Capturing)

JavaScript 的事件模型中，當一個事件在 DOM 元素上發生時，它不只會觸發該元素上的監聽器，還會在 DOM 樹中傳播。這種傳播有兩個階段：**捕獲 (Capturing)** 和 **冒泡 (Bubbling)**。

## 1. 事件流 (Event Flow)

當一個事件（例如點擊）發生在一個子元素上時，瀏覽器會：

1.  **捕獲階段 (Capturing Phase)**：事件從 `window` 物件開始，向下傳播到目標元素。
2.  **目標階段 (Target Phase)**：事件到達實際觸發事件的元素。
3.  **冒泡階段 (Bubbling Phase)**：事件從目標元素開始，向上傳播到 `window` 物件。

大部分事件都是從捕獲階段開始，然後到達目標，最後進行冒泡。

## 2. 範例 HTML 結構

```html
<div id="grandparent">
    <div id="parent">
        <button id="child">Click Me</button>
    </div>
</div>
```

## 3. 註冊事件監聽器與階段

`addEventListener()` 的第三個參數（或 `options` 物件的 `capture` 屬性）可以控制事件是在哪個階段被監聽。

*   `false` (預設值)：在**冒泡階段**執行處理器。
*   `true`：在**捕獲階段**執行處理器。

### 冒泡階段監聽 (預設)

```javascript
const grandparent = document.querySelector("#grandparent");
const parent = document.querySelector("#parent");
const child = document.querySelector("#child");

grandparent.addEventListener('click', function() {
    console.log('Grandparent (冒泡)');
});

parent.addEventListener('click', function() {
    console.log('Parent (冒泡)');
});

child.addEventListener('click', function() {
    console.log('Child (冒泡) - 目標');
});
```
當點擊 `child` 按鈕時，輸出順序：
1.  Child (冒泡) - 目標
2.  Parent (冒泡)
3.  Grandparent (冒泡)

### 捕獲階段監聽

```javascript
grandparent.addEventListener('click', function() {
    console.log('Grandparent (捕獲)');
}, true); // 設定為 true

parent.addEventListener('click', function() {
    console.log('Parent (捕獲)');
}, true);

child.addEventListener('click', function() {
    console.log('Child (捕獲) - 目標');
}, true);
```
當點擊 `child` 按鈕時，輸出順序：
1.  Grandparent (捕獲)
2.  Parent (捕獲)
3.  Child (捕獲) - 目標

### 混合使用

```javascript
grandparent.addEventListener('click', function() { console.log('Grandparent (捕獲)'); }, true);
parent.addEventListener('click', function() { console.log('Parent (冒泡)'); });
child.addEventListener('click', function() { console.log('Child (目標)'); });
```
點擊 `child`：
1.  Grandparent (捕獲)
2.  Child (目標)
3.  Parent (冒泡)

## 4. 阻止事件傳播

### `event.stopPropagation()`
阻止事件在 DOM 樹中**進一步傳播**（無論是冒泡還是捕獲）。

```javascript
child.addEventListener('click', function(event) {
    console.log('Child clicked!');
    event.stopPropagation(); // 阻止事件向上冒泡
});

parent.addEventListener('click', function() {
    console.log('Parent clicked!'); // 不會被執行
});
```

### `event.stopImmediatePropagation()`
不僅阻止事件在 DOM 樹中傳播，還阻止**同一個元素上**的其他監聽器被觸發。

## 5. 事件委派 (Event Delegation)

利用事件冒泡的特性，我們可以只在父元素上註冊一個事件監聽器，來處理所有子元素的事件。這對於動態新增的元素特別有用，因為它們在頁面載入時可能還不存在。

```html
<ul id="myList">
    <li>Item 1</li>
    <li>Item 2</li>
    <li>Item 3</li>
</ul>
```
```javascript
const myList = document.querySelector("#myList");

myList.addEventListener('click', function(event) {
    // 檢查點擊是否來自 li 元素
    if (event.target.tagName === 'LI') {
        console.log('Clicked on:', event.target.textContent);
    }
});
```
