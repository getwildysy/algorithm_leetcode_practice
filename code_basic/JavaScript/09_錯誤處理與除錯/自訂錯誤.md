# JavaScript 錯誤處理：自訂錯誤 (Custom Errors)

雖然 JavaScript 提供了多種內建的錯誤類型 (`Error`, `TypeError`, `ReferenceError` 等)，但在某些情況下，我們可能需要定義自己的錯誤類型，以便更具體地表示程式中發生的問題。這對於錯誤的分類、日誌記錄和使用者提示都非常有幫助。

## 1. 為什麼要自訂錯誤？

*   **更清晰的錯誤訊息**：能夠精確地描述應用程式特有的錯誤情境。
*   **更好的錯誤分類**：允許我們根據錯誤類型來執行不同的錯誤處理邏輯。
*   **提高可讀性和可維護性**：讓程式碼的意圖更明確。

## 2. 建立自訂錯誤類別

在 ES6 中，我們可以透過繼承內建的 `Error` 類別來建立自訂錯誤。

```javascript
// 定義一個繼承自 Error 的自訂錯誤類別
class ValidationError extends Error {
    constructor(message, field = 'unknown') {
        super(message); // 呼叫父類別 Error 的建構函式
        this.name = "ValidationError"; // 設定錯誤名稱
        this.field = field; // 新增自訂屬性
    }
}

class NetworkError extends Error {
    constructor(message, statusCode = 500) {
        super(message);
        this.name = "NetworkError";
        this.statusCode = statusCode;
    }
}
```

## 3. 拋出與捕捉自訂錯誤

使用 `throw` 語句拋出自訂錯誤，並使用 `try...catch` 捕捉。在 `catch` 區塊中，可以使用 `instanceof` 來判斷錯誤的類型，從而執行不同的處理邏輯。

```javascript
function validateInput(value, type) {
    if (type === 'email' && !value.includes('@')) {
        throw new ValidationError("Email 格式無效", "email");
    }
    if (type === 'age' && (typeof value !== 'number' || value < 0)) {
        throw new ValidationError("年齡必須是非負數", "age");
    }
    return true;
}

function fetchDataFromServer(url) {
    // 模擬網路請求失敗
    const isNetworkDown = true; 
    if (isNetworkDown) {
        throw new NetworkError("無法連接到伺服器", 503);
    }
    return { data: "..." };
}

try {
    validateInput("test@example.com", "email");
    validateInput(25, "age");
    fetchDataFromServer("https://api.example.com");

    // 故意製造一個錯誤來測試
    validateInput("invalid-email", "email"); 

} catch (error) {
    if (error instanceof ValidationError) {
        console.error(`驗證錯誤發生在 ${error.field}: ${error.message}`);
    } else if (error instanceof NetworkError) {
        console.error(`網路錯誤 ${error.statusCode}: ${error.message}`);
    } else {
        console.error("未知錯誤:", error);
    }
}
```

## 4. `Error.captureStackTrace` (Node.js) / `Error.stack` (瀏覽器)

當你建立自訂錯誤時，錯誤物件通常會自動帶有堆疊追蹤 (Stack Trace)。在瀏覽器環境下，`Error.stack` 屬性會包含呼叫堆疊。在 Node.js 環境下，可以利用 `Error.captureStackTrace(this, this.constructor)` 在建構函式中自訂堆疊追蹤的起點，使堆疊訊息更乾淨。

```javascript
// 在 Node.js 環境下可能會這樣寫
class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name; // 讓錯誤名稱自動匹配類別名
        // 捕捉堆疊追蹤，並移除建構函式本身在堆疊中的顯示
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
```
