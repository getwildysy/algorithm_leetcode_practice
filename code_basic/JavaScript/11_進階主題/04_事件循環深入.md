# 事件循環深入 (Event Loop Deep Dive)

事件循環 (Event Loop) 是 JavaScript 運行時環境的核心機制，它決定了程式碼的執行順序。雖然 JavaScript 是單執行緒的，但透過事件循環，它能夠處理非同步操作而不會阻塞主執行緒。之前已經介紹過基礎概念，這裡將更深入探討。

## 1. 運行時組件複習

1.  **Call Stack (呼叫堆疊)**：執行同步程式碼的地方，一次只執行一個任務。
2.  **Web APIs (瀏覽器/Node.js API)**：處理非同步操作的環境功能（`setTimeout`, `fetch`, DOM 事件等）。
3.  **Callback Queues (回呼佇列)**：
    *   **Microtask Queue (微任務佇列)**：存放 Promise 的 `then/catch/finally` 回呼、`queueMicrotask`。
    *   **Macrotask Queue (宏任務佇列)**：存放 `setTimeout`, `setInterval`, I/O, UI 渲染等回呼。
4.  **Event Loop (事件循環)**：不斷檢查 Call Stack 是否為空，並從佇列中取出任務推入 Call Stack。

## 2. 執行優先級

事件循環的關鍵在於其執行優先級：

1.  **優先執行 Call Stack 中的所有同步程式碼。**
2.  **Call Stack 清空後，執行所有 Microtask Queue 中的任務，直到清空為止。**
3.  **Microtask Queue 清空後，執行 Macrotask Queue 中的**一個**任務。**
4.  **重複步驟 2 和 3。**

這意味著一個 Macrotask 會被完整執行，然後所有等待的 Microtasks 會被執行，然後才會執行下一個 Macrotask。

## 3. 範例分析

```javascript
console.log('Script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

Promise.resolve()
  .then(() => console.log('Promise 1'))
  .then(() => console.log('Promise 2'));

queueMicrotask(() => console.log('queueMicrotask'));

console.log('Script end');
```

**詳細執行步驟：**

1.  **同步執行階段：**
    *   `console.log('Script start')` -> 印出 `Script start`。
    *   `setTimeout` 註冊一個 Macrotask (`setTimeout` 回呼) 到 Macrotask Queue。
    *   `Promise.resolve().then(...)` 創建一個已解決的 Promise，其 `.then()` 回呼 (`Promise 1`) 作為一個 Microtask 加入 Microtask Queue。
    *   第一個 `.then()` 的回呼 (`Promise 1`) 執行完後，其內部回傳的 Promise 會將第二個 `.then()` 回呼 (`Promise 2`) 作為另一個 Microtask 加入 Microtask Queue。
    *   `queueMicrotask` 將回呼 (`queueMicrotask` 回呼) 作為一個 Microtask 加入 Microtask Queue。
    *   `console.log('Script end')` -> 印出 `Script end`。
    *   Call Stack 清空。

2.  **Microtask Queue 處理階段：**
    *   Event Loop 發現 Call Stack 為空，檢查 Microtask Queue。
    *   取出 `Promise 1` 回呼 -> 印出 `Promise 1`。
    *   取出 `queueMicrotask` 回呼 -> 印出 `queueMicrotask`。
    *   取出 `Promise 2` 回呼 -> 印出 `Promise 2`。
    *   Microtask Queue 清空。

3.  **Macrotask Queue 處理階段：**
    *   Event Loop 檢查 Macrotask Queue。
    *   取出 `setTimeout` 回呼 -> 印出 `setTimeout`。
    *   Macrotask Queue 還有任務嗎？目前沒有。

**最終輸出：**
Script start
Script end
Promise 1
queueMicrotask
Promise 2
setTimeout

## 4. `requestAnimationFrame`

`requestAnimationFrame` (rAF) 用於優化動畫和視覺更新。它的回呼會在瀏覽器**下一次重繪前**執行，且只有一個。這使得它非常適合需要頻繁更新 UI 的場景，因為它能確保動畫流暢且與螢幕重新整理頻率同步。

*   rAF 的回呼通常被視為與 UI 渲染同級別，在 Microtask 執行完後，但在下一個 Macrotask 之前執行。

## 5. `setImmediate` (Node.js Only)

`setImmediate` 是 Node.js 特有的，它會在當前事件循環的**下一個循環**中執行回呼。在某些情況下，它的執行優先級可能比 `setTimeout(..., 0)` 更高。
