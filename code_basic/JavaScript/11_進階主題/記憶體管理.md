# JavaScript 記憶體管理 (Memory Management)

JavaScript 是一種高階語言，具有自動記憶體管理機制。這意味著開發者通常不需要手動分配和釋放記憶體。這個自動管理主要透過**垃圾回收 (Garbage Collection)** 來實現。然而，了解其工作原理有助於編寫更高效的程式碼並避免記憶體洩漏 (Memory Leaks)。

## 1. 記憶體生命週期

任何程式語言的記憶體生命週期大致相同：

1.  **記憶體分配**：當宣告變數、函式、物件時，系統會為其分配記憶體空間。
2.  **記憶體使用**：讀取或寫入記憶體中的變數和物件。
3.  **記憶體釋放**：不再需要變數或物件時，將其佔用的記憶體空間歸還給系統。

## 2. JavaScript 的記憶體分配

### (1) 堆疊 (Stack)
用於儲存**基本型別 (Primitives)** 的值和函式呼叫。這些數據的大小是固定的，並且按照先進後出 (LIFO) 的順序自動分配和釋放。

### (2) 堆 (Heap)
用於儲存**物件型別 (Objects)** 的值。這些數據的大小通常是動態的，並且通過指標 (Pointer) 引用。

```javascript
let num = 10;          // 儲存在 Stack
let name = "Alice";    // 儲存在 Stack

let person = {         // 物件本身儲存在 Heap，person 變數儲存在 Stack 並指向 Heap 的記憶體位址
    name: name,
    age: num
};
```

## 3. 垃圾回收 (Garbage Collection)

JavaScript 引擎中的垃圾回收器負責自動檢測不再被引用的物件，並回收其佔用的記憶體。

### (1) 引用計數 (Reference Counting) - 已淘汰

這是最初的垃圾回收演算法。它追蹤每個物件被引用的次數。當引用次數歸零時，該物件就會被回收。

**缺點**：無法解決**循環引用 (Circular References)** 的問題。

```javascript
let obj1 = {};
let obj2 = {};

obj1.a = obj2; // obj1 引用 obj2 (引用計數 = 1)
obj2.a = obj1; // obj2 引用 obj1 (引用計數 = 1)

obj1 = null; // obj1 不再引用 obj2 (obj2 的引用計數仍為 1)
obj2 = null; // obj2 不再引用 obj1 (obj1 的引用計數仍為 1)

// 兩個物件互相引用，引用計數永遠不會歸零，導致記憶體洩漏。
```

### (2) 標記清除 (Mark-and-Sweep) - 現代主流

現代瀏覽器和 Node.js 主要使用這種演算法。

**步驟**：
1.  **標記 (Mark)**：垃圾回收器從根物件（例如全域物件 `window`）開始，遞迴地遍歷所有從根可達的物件，並將它們標記為「活躍」。
2.  **清除 (Sweep)**：遍歷堆中所有物件，將所有未被標記為活躍的物件清除。

這種演算法可以有效解決循環引用的問題。

## 4. 記憶體洩漏 (Memory Leaks)

記憶體洩漏是指應用程式不再需要的記憶體沒有被回收，導致記憶體佔用持續增加，最終可能導致程式效能下降甚至崩潰。

### 常見的記憶體洩漏原因：

1.  **全域變數**：不小心建立的全域變數（例如沒有宣告的變數）會被視為根物件的一部分，永遠不會被回收。
    ```javascript
    function createLeak() {
        leakyVar = "這是一個全域變數，可能導致洩漏"; // 沒有用 let/const/var 宣告
    }
    ```

2.  **計時器 (Timers)**：`setTimeout` 或 `setInterval` 的回呼函式如果引用了外部作用域的變數，即使計時器本身已經不再需要，回呼函式及其引用的變數也不會被回收，直到計時器被清除。
    ```javascript
    let element = document.getElementById('myDiv');
    setInterval(() => {
        if (element) {
            element.innerHTML += 'Hello';
        }
    }, 1000);
    // 如果 element 被從 DOM 中移除了，但計時器還在運行，element 仍然會被引用，導致洩漏。
    // 正確做法：在 element 移除時清除計時器
    ```

3.  **事件監聽器**：如果事件監聽器沒有被正確移除，即使 DOM 元素被移除，監聽器及其閉包引用的變數也可能導致洩漏。
    ```javascript
    const btn = document.getElementById('myButton');
    btn.addEventListener('click', () => {
        // 這個回呼函式會一直存在，直到 btn 被移除或頁面卸載
    });
    // 如果 btn 被移除，但監聽器沒移除，就可能洩漏
    ```

4.  **閉包 (Closures)**：閉包本身並不是洩漏，但如果閉包意外地保留了對大型物件的引用，並且閉包長時間存在，就可能導致記憶體無法釋放。

5.  **DOM 引用**：將 DOM 元素儲存在 JavaScript 變數中，然後從 DOM 中移除該元素，但變數沒有清空對該元素的引用。

## 5. 避免記憶體洩漏的策略

*   **避免不必要全域變數**：總是使用 `const`, `let`, `var` 宣告變數。
*   **清除計時器**：在組件銷毀或不再需要時，使用 `clearTimeout` 和 `clearInterval`。
*   **移除事件監聽器**：在組件銷毀時使用 `removeEventListener`。
*   **斷開不必要的引用**：在不再需要時，將變數設置為 `null`，特別是對於大型物件。
*   **使用弱引用**：在某些進階場景中，可以考慮使用 `WeakMap` 或 `WeakSet`。
*   **使用瀏覽器開發者工具**：利用 Performance 和 Memory 面板監控記憶體使用情況。
