# 第 6 章：資料庫整合 (Database Integration)

全端開發的核心就是與資料庫對話。在 Next.js 生態系中，**Prisma** 是目前最受歡迎的 ORM (Object-Relational Mapping) 工具。它讓我們可以用 TypeScript 定義資料結構，並自動產生強型別的資料庫客戶端。

## 6.1 ORM 的選擇：Prisma

### 為什麼選 Prisma？
1.  **Type-safe**：查詢結果自動有 TS 型別，不用再手寫 interface。
2.  **Schema First**：用一個 `schema.prisma` 檔案定義所有 tables，一目瞭然。
3.  **Migration**：自動產生 SQL 腳本來同步資料庫結構。

### 安裝與初始化
```bash
npm install prisma --save-dev
npm install @prisma/client
npx prisma init
```

這會產生 `/prisma/schema.prisma` 檔案。

---

## 6.2 Schema 定義與 Migration

讓我們來設計一個簡單的部落格資料庫。

### 編輯 `schema.prisma`

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite" // 開發時用 sqlite 最簡單，上線可改 postgresql
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}
```

### 執行 Migration
將這個結構同步到資料庫：
```bash
npx prisma migrate dev --name init
```
這會建立一個 SQLite 檔案，並產生對應的 TS Client。

---

## 6.3 在 Next.js 中使用 Prisma

由前面章節所學，我們應該在 **Server Components** 或 **Server Actions** 中直接呼叫 Prisma。

### 最佳實踐：Global Prisma Client
為了避免在開發環境 (HMR) 中產生太多連線，我們需要一個單例模式的 Client 實體。

建立 `lib/prisma.ts`：
```ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: ['query'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

### 查詢資料 (Read)
```tsx
// app/posts/page.tsx
import { prisma } from '@/lib/prisma';

export default async function Posts() {
  // 自動獲得型別推斷！
  const posts = await prisma.post.findMany({
    where: { published: true },
    include: { author: true }, // 連這個也幫你 Join 好了
  });

  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>
          {post.title} by {post.author.name}
        </li>
      ))}
    </ul>
  );
}
```

### 寫入資料 (Write)
結合 Server Actions：
```tsx
// app/actions.ts
'use server';
import { prisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';

export async function createPost(formData: FormData) {
  await prisma.post.create({
    data: {
      title: formData.get('title') as string,
      authorId: 1, // 暫時寫死
    },
  });
  revalidatePath('/posts');
}
```

---

## [範例演練]：將 Todo List 改寫為資料庫版本

延續上一章的 Todo List，這次我們玩真的。

1.  **更新 Schema**
    在 `schema.prisma` 加入：
    ```prisma
    model Todo {
      id        String   @id @default(cuid())
      title     String
      completed Boolean  @default(false)
      createdAt DateTime @default(now())
    }
    ```
    執行 `npx prisma migrate dev --name add_todo`。

2.  **讀取 Todo (Page)**
    ```tsx
    // app/todos/page.tsx
    import { prisma } from '@/lib/prisma';
    // ... import actions ...

    export default async function Page() {
      const todos = await prisma.todo.findMany({
        orderBy: { createdAt: 'desc' }
      });

      return (
        <ul>
          {todos.map(todo => (
            <li key={todo.id}>
              {todo.completed ? '✅' : '⬜'} {todo.title}
            </li>
          ))}
        </ul>
      );
    }
    ```

3.  **新增 Todo (Action)**
    ```tsx
    // app/todos/actions.ts
    'use server';
    import { prisma } from '@/lib/prisma';
    import { revalidatePath } from 'next/cache';

    export async function addTodo(formData: FormData) {
      const title = formData.get('title') as string;
      if (!title) return;

      await prisma.todo.create({
        data: { title }
      });
      
      revalidatePath('/todos');
    }
    ```

恭喜！你已經完成了一個真正的全端應用功能。
