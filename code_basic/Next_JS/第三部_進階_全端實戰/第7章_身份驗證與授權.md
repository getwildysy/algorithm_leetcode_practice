# 第 7 章：身份驗證與授權 (Authentication)

身份驗證 (Authentication) 是全端應用最困難也最重要的部分之一。幸運的是，我們有 **NextAuth.js (現在更名為 Auth.js)**，它完美整合了 Next.js 的 App Router 架構。

## 7.1 NextAuth.js (Auth.js) v5 實戰

NextAuth.js v5 針對 App Router 做了大量優化，支援 Server Actions 與 Middleware 驗證。

### 安裝
```bash
npm install next-auth@beta
```
*(註：目前 v5 仍為 beta，但已相當穩定)*

### 設定流程
Auth.js 的設定需要一個 `auth.ts` 核心檔案。

```ts
// auth.ts
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
import Credentials from "next-auth/providers/credentials"

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    // 1. OAuth 登入 (推薦)
    GitHub({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET,
    }),
    // 2. 帳號密碼登入 (權衡之下較不安全，但實務常用)
    Credentials({
      // 自定義驗證邏輯...
    }),
  ],
})
```

接著建立 API Route 讓前端可以呼叫：
```ts
// app/api/auth/[...nextauth]/route.ts
import { handlers } from "@/auth" // 引用上面的 auth.ts
export const { GET, POST } = handlers
```

---

## 7.2 Middleware (中介軟體) 保護路由

Middleware 允許你在 request 到達頁面之前進行攔截。這是實作「登入轉向」的最佳地點。

建立 `middleware.ts` 在專案根目錄：

```ts
import { auth } from "@/auth"

export default auth((req) => {
  const isLoggedIn = !!req.auth
  const isOnDashboard = req.nextUrl.pathname.startsWith('/dashboard')

  if (isOnDashboard) {
    if (isLoggedIn) return true
    return Response.redirect(new URL('/login', req.nextUrl)) // 沒登入就踢去登入頁
  }
  return true
})

// 設定 Middleware 要監聽的路徑
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}
```

---

## 7.3 Server 與 Client 端的 Session 存取

在不同環境取得「當前使用者」的方法不同。

### Server Component (最推薦)
```tsx
import { auth } from "@/auth"

export default async function Page() {
  const session = await auth()
  
  if (!session?.user) return <div>請先登入</div>

  return <h1>歡迎回來, {session.user.name}</h1>
}
```

### Client Component
需要先在 `layout.tsx` 包裹 `<SessionProvider>`。

```tsx
'use client'
import { useSession } from "next-auth/react"

export default function UserMenu() {
  const { data: session } = useSession()
  
  if (session) {
    return <p>{session.user?.email}</p>
  }
  return <a href="/api/auth/signin">登入</a>
}
```

---

## [範例演練]：實作會員專屬頁面

我們來做一個「只有登入才能看見的機密頁面」。

1.  **設定環境變數 (.env)**
    你需要去 GitHub Developer Settings 申請 OAuth App。
    ```text
    AUTH_SECRET="your-random-secret"
    GITHUB_ID="your-client-id"
    GITHUB_SECRET="your-client-secret"
    ```

2.  **建立登入按鈕元件 (`components/auth-buttons.tsx`)**
    ```tsx
    import { signIn, signOut } from "@/auth"

    export function LoginButton() {
      return (
        <form action={async () => {
          "use server"
          await signIn("github")
        }}>
          <button type="submit">使用 GitHub 登入</button>
        </form>
      )
    }

    export function LogoutButton() {
      return (
        <form action={async () => {
          "use server"
          await signOut()
        }}>
          <button type="submit">登出</button>
        </form>
      )
    }
    ```

3.  **機密頁面 (`app/dashboard/page.tsx`)**
    ```tsx
    import { auth } from "@/auth"
    import { LogoutButton } from "@/components/auth-buttons"

    export default async function Dashboard() {
      const session = await auth()
      // 雖然 middleware 有擋，但這裡雙重檢查更保險
      if (!session?.user) return <div>Access Denied</div>

      return (
        <div>
          <h1>機密儀表板</h1>
          <p>只有你看得到這行字，{session.user.name}</p>
          <img src={session.user.image!} alt="Avatar" width={50} />
          
          <LogoutButton />
        </div>
      )
    }
    ```

藉由 NextAuth.js，我們在短短幾行程式碼內就完成了軍規級的身份驗證系統。
