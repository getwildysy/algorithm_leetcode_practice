# 第 3 章：資料獲取與快取 (Data Fetching & Caching)

Next.js 的 App Router 徹底顛覆了我們過去在 React 中使用 `useEffect` + `fetch` 的習慣。現在，獲取資料 (Data Fetching) 是 Server Components 的第一公民，而且預設就內建了強大的快取機制。

## 3.1 伺服器端的 Fetch API

在 Server Component 中，你可以直接把 component 寫成 `async` function，然後在裡面 `await fetch()`。

### 為什麼這很棒？
1.  **安全性**：API Key 等敏感資訊只留在伺服器，不會洩漏給瀏覽器。
2.  **效能**：資料庫就在伺服器旁，延遲極低。減少了 Client 與 Server 之間的來回通訊 (Round trip)。
3.  **簡潔**：不再需要處理 `isLoading` 狀態變數（稍後在第 4 章會介紹 Suspense 如何優雅處理載入中）。

### 程式碼範例
```tsx
// app/news/page.tsx
async function getNews() {
  const res = await fetch('https://api.example.com/news');
  if (!res.ok) throw new Error('Failed to fetch data');
  return res.json();
}

export default async function NewsPage() {
  const data = await getNews();

  return (
    <main>
      <h1>最新新聞</h1>
      <ul>
        {data.map((item: any) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </main>
  );
}
```

---

## 3.2 快取策略 (Caching Strategies)

Next.js 擴充了原生的 `fetch` API，讓你可以透過參數精細控制快取行為。

### 1. 預設：靜態快取 (force-cache)
如果你什麼都不設定，Next.js 預設會把結果快取起來，直到你下次部署網站。這相當於 SSG。
```tsx
fetch('https://...', { cache: 'force-cache' }); // 預設值
```

### 2. 動態資料 (no-store)
如果資料隨時在變（例如股市報價），你需要告訴 Next.js 每次都要去抓最新的。這相當於 SSR。
```tsx
fetch('https://...', { cache: 'no-store' });
```

### 3. 定時更新 (ISR - revalidate)
這是最實用的模式。例如：部落格文章不需要每秒更新，但也不想每次改錯字都要重新部署。你可以設定「每 60 秒更新一次」。
```tsx
fetch('https://...', { next: { revalidate: 60 } });
```

---

## 3.3 解決瀑布流 (Waterfalls)

在元件樹中，如果父元件 await 資料後才渲染子元件，而子元件又要 await 資料，就會形成「請求瀑布流 (Request Waterfall)」，導致載入變慢。

### 錯誤示範 (Sequential)
```tsx
const user = await getUser();      // 等 1 秒
const posts = await getPosts();    // 這裡才開始跑，又等 1 秒 -> 總共 2 秒
```

### 優化示範 (Parallel)
使用 `Promise.all` 平行發送請求。
```tsx
const userData = getUser();
const postsData = getPosts();

// 同時發送，總共只需等待最慢的那一個 (約 1 秒)
const [user, posts] = await Promise.all([userData, postsData]);
```

---

## 3.4 Static Params：靜態路由生成

對於動態路由（如 `/blog/[id]`），我們希望能預先生成靜態 HTML (SSG)，而不是使用者訪問時才算 (SSR)。這時就需要 `generateStaticParams`。

```tsx
// app/blog/[id]/page.tsx

// 1. 告訴 Next.js 有哪些 id 需要預先生成
export async function generateStaticParams() {
  const posts = await fetch('https://api.example.com/posts').then(res => res.json());
  
  return posts.map((post: any) => ({
    id: post.id.toString(),
  }));
}

// 2. 一般的頁面邏輯
export default async function Page({ params }: { params: { id: string } }) {
  // ...
}
```
這樣在 `next build` 建置時，Next.js 就會自動把所有的文章頁面都產生成 HTML 檔案。

---

## [範例演練]：實作「新聞列表」並設定 ISR

我們來做一個簡易的新聞頁面，並設定每 10 秒更新一次資料，體驗 ISR 的魔力。

1.  **建立 `app/news/page.tsx`**

```tsx
// app/news/page.tsx

interface NewsItem {
  id: number;
  title: string;
  publishedAt: string;
}

// 模擬一個慢速 API
async function fetchNews(): Promise<NewsItem[]> {
  // 這裡使用 dummyjson 公開 API
  const res = await fetch('https://dummyjson.com/posts?limit=5', {
    next: { revalidate: 10 }, // 重點：設定 10 秒 ISR
  });
  
  const data = await res.json();
  return data.posts;
}

export default async function NewsPage() {
  const news = await fetchNews();
  const time = new Date().toLocaleTimeString();

  return (
    <div style={{ padding: '2rem' }}>
      <h1>熱門即時新聞</h1>
      <p style={{ color: 'red' }}>最後更新時間：{time} (請觀察 10 秒內的變化)</p>
      
      <ul>
        {news.map((item) => (
          <li key={item.id} style={{ margin: '10px 0', padding: '10px', border: '1px solid #ddd' }}>
            <h3>{item.title}</h3>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

2.  **測試 ISR**
    *   執行 `npm run build` 然後 `npm start` (ISR 在 dev 模式下看不太出效果，建議 build 後測試)。
    *   開啟網頁，記下「最後更新時間」。
    *   在 10 秒內瘋狂重新整理 -> 時間**不會**變（因為是快取的）。
    *   過了 10 秒後重新整理 -> 時間變了！（React 在背景偷偷更新了）。

這就是 ISR：兼具靜態網站的極速，與動態網站的即時性。
