# 第 5 章：互動與變更 (Mutation & Interaction)

在 Next.js 的世界裡，讀取資料 (Query) 用 Server Components，那麼修改資料 (Mutation) 呢？以前我們得寫一支 API Route (`/api/todos`)，然後前端 `fetch('/api/todos', { method: 'POST' })`。

現在，Next.js 13.4 正式推出了 **Server Actions**。你可以直接在 Server Component 裡寫一個 function，然後在 Client 端的 form 裡面直接呼叫它。這感覺就像在寫 PHP，但擁有 React 的現代化體驗。

## 5.1 Server Actions 入門

Server Action 就是一個執行在伺服器端的非同步函式。

### 定義方式
在函式開頭加上 `'use server'`。

```tsx
// app/actions.ts
'use server';

export async function createTodo(formData: FormData) {
  const title = formData.get('title');
  // 直接操作資料庫
  await db.todo.create({ data: { title } });
}
```

### 使用方式
直接放在 `<form>` 的 `action` 屬性中。

```tsx
// app/page.tsx
import { createTodo } from './actions';

export default function Page() {
  return (
    <form action={createTodo}>
      <input name="title" />
      <button type="submit">新增待辦</button>
    </form>
  );
}
```
沒錯，完全不需要 `useState`, `onSubmit`, `e.preventDefault()`, 也不用 `fetch`。這就是 Progressive Enhancement (漸進增強)，即使瀏覽器 JS 被停用，這個表單依然能運作！

---

## 5.2 表單狀態管理：useFormStatus

雖然 Server Actions 不依賴 JS，但我們通常希望給使用者更好的體驗（例如：按鈕顯示「送出中...」並 disable）。這時可以使用 `useFormStatus` Hook。

**注意**：`useFormStatus` 必須在 `<form>` 內部的元件中使用。

```tsx
// SubmitButton.tsx
'use client';
import { useFormStatus } from 'react-dom';

export function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? '新增中...' : '新增待辦'}
    </button>
  );
}
```

---

## 5.3 重新驗證資料：revalidatePath

Server Action 修改資料庫後，使用者的畫面通常還是舊的。我們需要告訴 Next.js：「這頁資料髒了，請重抓。」

```tsx
'use server';
import { revalidatePath } from 'next/cache';

export async function createTodo(formData: FormData) {
  // 1. 改資料庫
  await db.todo.create({ ... });
  
  // 2. 清除快取，讓頁面下次渲染時抓到最新資料
  revalidatePath('/todos'); 
}
```
這個指令會瞬間觸發 Server Component 的重新渲染，並把最新的 HTML 串流回瀏覽器，使用者會看到列表自動更新，而且**完全沒有頁面閃爍**。

---

## [範例演練]：製作「待辦事項清單 (Todo List)」

我們來整合本章所學，做一個極簡的 Todo List。為了簡化，我們用一個全域變數模擬資料庫。

1.  **建立 `app/todos/actions.ts`**

```ts
'use server';

import { revalidatePath } from 'next/cache';

// 模擬資料庫
let todos = ['買牛奶', '寫程式'];

export async function addTodo(formData: FormData) {
  // 模擬網路延遲
  await new Promise(resolve => setTimeout(resolve, 1000));

  const title = formData.get('title') as string;
  if(title) {
    todos.push(title);
    revalidatePath('/todos'); // 關鍵！更新完後刷新頁面
  }
}
```

2.  **建立 `app/todos/page.tsx`**

```tsx
import { addTodo } from './actions';
// 為了使用 useFormStatus，我們需要把按鈕抽成 Client Component
import { SubmitButton } from './SubmitButton'; 

// 模擬從資料庫讀取
async function getTodos() {
  // 這裡 import 上面那個變數有點髒，但在範例中為了方便演示
  const { todos } from './_db'; // 假設你有把 todos 變數 export 出來
  return todos; 
  // 備註：實作時請直接在此檔案定義 todos 陣列或使用真實 DB
}
// 修正：為了方便，我們把 todos 放在 page 外面 (但在真實 serverless 環境這樣不會持久)
let todos = ['買牛奶', '寫程式'];

async function addTodoAction(formData: FormData) {
  'use server';
  await new Promise(r => setTimeout(r, 1000));
  const title = formData.get('title') as string;
  if(title) todos.push(title);
  revalidatePath('/todos');
}

export default async function TodoPage() {
  return (
    <div style={{ padding: '2rem' }}>
      <h1>Todo List (Server Actions)</h1>
      
      <ul>
        {todos.map((t, i) => <li key={i}>{t}</li>)}
      </ul>

      <hr />

      <form action={addTodoAction} style={{ display: 'flex', gap: '10px' }}>
        <input name="title" placeholder="輸入事項..." required />
        <SubmitButton />
      </form>
    </div>
  );
}
```

3.  **建立 `app/todos/SubmitButton.tsx`**

```tsx
'use client';
import { useFormStatus } from 'react-dom';

export function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? '⏳處理中...' : '➕ 新增'}
    </button>
  );
}
```

4.  **體驗**
    *   在輸入框打字，按 Enter。
    *   你會看到按鈕變灰並顯示「處理中...」。
    *   1 秒後，按鈕恢復，且上方列表**自動**出現新項目。
    *   感覺就像 SPA 一樣流暢，但你就只寫了一個 HTML Form 而已！
