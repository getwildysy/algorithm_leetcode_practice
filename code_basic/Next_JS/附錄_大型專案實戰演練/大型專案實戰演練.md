# 附錄：大型專案實戰演練 (Capstone Project)

**主題**：SaaS 級別的「技術文件共筆平台」 (類似 Notion 或 GitBook 的簡化版)

本附錄將不只是一個章節，而是一個完整的開發藍圖。我們將綜合運用本書 1-10 章的所有知識，從零打造一個可上線的產品。

## 專案規格 (Spec)

### 核心功能
1.  **首頁 (ISR)**：展示熱門文件與最新更新，每 60 秒重新生成。
2.  **文件閱讀器 (Dynamic Routes + MDX)**：
    *   使用者可以瀏覽 `/docs/[slug]`。
    *   內容支援 Markdown 語法。
    *   側邊欄導航 (Layout)。
3.  **後台管理 (Server Actions + Auth)**：
    *   只有管理員能登入。
    *   新增、編輯、刪除文件。
    *   即時預覽 (Client Component)。
4.  **搜尋系統 (URL Search Params)**：
    *   全站關鍵字搜尋。
    *   使用 Debounce 減少請求。

### 技術堆疊
*   **Framework**: Next.js 14+ (App Router)
*   **Database**: PostgreSQL (via Supabase or Neon)
*   **ORM**: Prisma
*   **Auth**: NextAuth.js v5
*   **Styling**: Tailwind CSS + Shadcn UI
*   **Deployment**: Vercel

---

## 階段一：資料建模與基礎建設

### `schema.prisma`

```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  role      String   @default("user") // admin, user
  documents Document[]
}

model Document {
  id        String   @id @default(cuid())
  slug      String   @unique
  title     String
  content   String   // Markdown content
  published Boolean  @default(false)
  views     Int      @default(0)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  updatedAt DateTime @updatedAt
}
```

---

## 階段二：文件閱讀器 (Front-end)

### 1. 動態路由 `app/docs/[slug]/page.tsx`
我們使用 `next-mdx-remote` 來渲染 Markdown，讓這變得很簡單。

```tsx
import { compileMDX } from 'next-mdx-remote/rsc'

export default async function DocPage({ params }: { params: { slug: string } }) {
  const doc = await prisma.document.findUnique({ where: { slug: params.slug } })
  
  if (!doc) notFound()

  // 增加瀏覽次數 (Server Action 或是直接寫在這裡，因是 Server Component)
  await prisma.document.update({
    where: { id: doc.id },
    data: { views: { increment: 1 } } 
  })

  const { content } = await compileMDX({ source: doc.content })

  return (
    <article className="prose lg:prose-xl">
      <h1>{doc.title}</h1>
      {content}
    </article>
  )
}
```

---

## 階段三：編輯器與管理後台 (Back-end logic)

我們需要一個強大的表單來處理文件編輯。

### Server Action: `saveDocument`

```ts
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { auth } from '@/auth'

export async function saveDocument(formData: FormData) {
  const session = await auth()
  if (session?.user?.role !== 'admin') throw new Error('Unauthorized')

  const title = formData.get('title')
  const content = formData.get('content')
  const slug = formData.get('slug')

  await prisma.document.upsert({
    where: { slug },
    update: { title, content },
    create: { title, content, slug, authorId: session.user.id }
  })

  revalidatePath(`/docs/${slug}`)
  redirect(`/docs/${slug}`)
}
```

---

## 階段四：全站搜尋 (Search)

利用 URL Search Params 實作 Shareable URL。

```tsx
// app/components/Search.tsx
'use client'

import { useSearchParams, usePathname, useRouter } from 'next/navigation'
import { useDebouncedCallback } from 'use-debounce';

export default function Search() {
  const searchParams = useSearchParams()
  const pathname = usePathname()
  const { replace } = useRouter()

  const handleSearch = useDebouncedCallback((term: string) => {
    const params = new URLSearchParams(searchParams)
    
    if (term) {
      params.set('query', term)
    } else {
      params.delete('query')
    }
    
    replace(`${pathname}?${params.toString()}`)
  }, 300)

  return (
    <input 
      placeholder="搜尋文件..." 
      onChange={(e) => handleSearch(e.target.value)}
      defaultValue={searchParams.get('query')?.toString()}
    />
  )
}
```

在 Server Component 接收 `searchParams` prop 並 Query 資料庫：

```tsx
// app/docs/page.tsx
export default async function DocsIndex({
  searchParams,
}: {
  searchParams?: {
    query?: string
    page?: string
  }
}) {
  const query = searchParams?.query || ''
  const docs = await prisma.document.findMany({
    where: {
      title: { contains: query }
    }
  })
  
  // Render list...
}
```

---

## 結語

完成這個專案後，你將擁有一個：
1.  **SEO 滿分**：因為內容都是 Server Render 的 HTML。
2.  **互動流暢**：搜尋與換頁都是客戶端導航。
3.  **容易維護**：Type-safe 的資料庫操作與清晰的 Server Actions。
4.  **可擴展**：可以輕鬆加入「會員訂閱」、「留言功能」等。

這就是 Next.js 全端開發的威力。祝你在全端航道上一帆風順！
