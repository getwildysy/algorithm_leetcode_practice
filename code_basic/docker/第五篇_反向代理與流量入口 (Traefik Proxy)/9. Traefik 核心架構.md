# 9. Traefik 核心架構

## 9.1. 現代反向代理的優勢：動態配置 vs. 靜態配置

### 傳統反向代理 (Nginx/Apache) 的問題

**Nginx 設定範例：**

```nginx
# /etc/nginx/conf.d/myapp.conf
upstream backend {
    server app1:4000;
    server app2:4000;
    server app3:4000;
}

server {
    listen 80;
    server_name example.com;

    location / {
        proxy_pass http://backend;
    }
}
```

**問題：**
1. ❌ 新增服務需要手動修改設定檔
2. ❌ 修改後需要重新載入 Nginx (`nginx -s reload`)
3. ❌ 容器 IP 變更需要更新設定
4. ❌ SSL 憑證需要手動更新

---

### Traefik 的動態配置優勢

**相同功能的 Traefik 設定：**

```yaml
services:
  app:
    image: myapp
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.myapp.rule=Host(`example.com`)"
```

**優勢：**
1. ✅ **自動服務發現**：容器啟動自動加入路由
2. ✅ **動態更新**：無需重啟 Traefik
3. ✅ **自動 SSL**：Let's Encrypt 自動申請/續期
4. ✅ **宣告式配置**：透過 labels 定義規則

---

### 動態配置 vs 靜態配置對比

| 特性 | Nginx (靜態) | Traefik (動態) |
|------|-----------|---------------|
| 新增服務 | 修改設定檔 + reload | 標籤即可，自動生效 |
| 容器重啟 | 可能需要更新IP | 自動偵測新IP |
| SSL 憑證 | 手動管理 Certbot | 自動申請/續期 |
| 負載平衡 | 手動定義 upstream | 自動發現多副本 |
| 設定模式 | 檔案配置 | 標籤/API/檔案 |
| 學習曲線 | 中等 | 低 |

---

## 9.2. Traefik 三大元件詳解：EntryPoints (入口)、Routers (路由)、Services (服務)

### Traefik 架構圖

```
Internet
   │
   ▼
┌──────────────────────────────────────────┐
│         EntryPoints (入口)               │
│  ┌────────┐  ┌────────┐  ┌─────────┐    │
│  │ :80    │  │ :443   │  │ :8080   │    │
│  │ (web)  │  │(websec)│  │(dashbrd)│    │
│  └────┬───┘  └───┬────┘  └─────────┘    │
└───────┼──────────┼───────────────────────┘
        │          │
        ▼          ▼
┌──────────────────────────────────────────┐
│         Routers (路由)                   │
│  ┌─────────────────────────────────┐    │
│  │ Host(`example.com`)             │    │
│  │ Path(`/api`)                    │    │
│  │ PathPrefix(`/static`)           │    │
│  └────────────┬────────────────────┘    │
└───────────────┼──────────────────────────┘
                │
                ▼
┌──────────────────────────────────────────┐
│         Services (服務)                  │
│  ┌───────────┐  ┌───────────┐           │
│  │   app1    │  │   app2    │           │
│  │ (backend) │  │ (backend) │           │
│  └───────────┘  └───────────┘           │
└──────────────────────────────────────────┘
```

---

### 1. EntryPoints (入口點)

**定義：** Traefik 監聽的網路 port

**靜態配置（traefik.yml）：**

```yaml
# traefik.yml
entryPoints:
  # HTTP 入口 (port 80)
  web:
    address: ":80"
    http:
      redirections:
        entryPoint:
          to: websecure  # 強制轉向 HTTPS
          scheme: https

  # HTTPS 入口 (port 443)
  websecure:
    address: ":443"
    http:
      tls:
        certResolver: letsencrypt  # 使用 Let's Encrypt

  # 管理介面 (port 8080)
  dashboard:
    address: ":8080"
```

**Docker Compose 設定：**

```yaml
services:
  traefik:
    image: traefik:v2.10
    ports:
      - "80:80"      # web
      - "443:443"    # websecure
      - "8080:8080"  # dashboard
    volumes:
      - ./traefik/traefik.yml:/traefik.yml:ro
```

---

### 2. Routers (路由器)

**定義：** 決定請求如何路由到後端服務

**路由規則類型：**

```yaml
# 1. Host：根據網域名稱
- "traefik.http.routers.app.rule=Host(`example.com`)"

# 2. Path：精確路徑
- "traefik.http.routers.api.rule=Path(`/api/v1/users`)"

# 3. PathPrefix：路徑前綴
- "traefik.http.routers.static.rule=PathPrefix(`/static`)"

# 4. Headers：HTTP 標頭
- "traefik.http.routers.app.rule=Header(`X-Custom-Header`, `value`)"

# 5. Method：HTTP 方法
- "traefik.http.routers.api.rule=Method(`POST`, `PUT`)"

# 6. Query：查詢參數
- "traefik.http.routers.app.rule=Query(`version`, `v2`)"

# 7. 組合規則（使用 && 或 ||）
- "traefik.http.routers.app.rule=Host(`example.com`) && PathPrefix(`/api`)"
- "traefik.http.routers.multi.rule=Host(`app1.com`) || Host(`app2.com`)"
```

**Router 設定範例：**

```yaml
services:
  frontend:
    image: frontend:latest
    labels:
      - "traefik.enable=true"
      
      # Router 名稱：frontend
      - "traefik.http.routers.frontend.rule=Host(`example.com`)"
      
      # 使用哪個 EntryPoint
      - "traefik.http.routers.frontend.entrypoints=websecure"
      
      # TLS 設定
      - "traefik.http.routers.frontend.tls=true"
      - "traefik.http.routers.frontend.tls.certresolver=letsencrypt"
      
      # 優先級（數字越大越優先）
      - "traefik.http.routers.frontend.priority=100"
```

---

### 3. Services (服務)

**定義：** 實際處理請求的後端服務

**基本設定：**

```yaml
services:
  api:
    image: myapi:latest
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.api.rule=PathPrefix(`/api`)"
      
      # Service 設定
      - "traefik.http.services.api.loadbalancer.server.port=4000"
      
      # 健康檢查
      - "traefik.http.services.api.loadbalancer.healthcheck.path=/health"
      - "traefik.http.services.api.loadbalancer.healthcheck.interval=10s"
      
      # Sticky Sessions（會話黏性）
      - "traefik.http.services.api.loadbalancer.sticky.cookie=true"
      - "traefik.http.services.api.loadbalancer.sticky.cookie.name=server_id"
```

**負載平衡範例：**

```yaml
services:
  api:
    image: myapi
    deploy:
      replicas: 3  # 建立 3 個副本
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.api.rule=PathPrefix(`/api`)"
      - "traefik.http.services.api.loadbalancer.server.port=4000"
```

Traefik 會自動發現所有 3 個副本並進行負載平衡。

---

### 完整範例：三大元件整合

```yaml
version: '3.8'

services:
  # ========================================
  # Traefik
  # ========================================
  traefik:
    image: traefik:v2.10
    command:
      # EntryPoints 定義
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      
      # 啟用 Docker Provider
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      
      # SSL 設定
      - "--certificatesresolvers.letsencrypt.acme.email=admin@example.com"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
      
      # 儀表板
      - "--api.dashboard=true"
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./letsencrypt:/letsencrypt
    networks:
      - traefik-public

  # ========================================
  # Frontend (React/Vue/Angular)
  # ========================================
  frontend:
    image: frontend:latest
    labels:
      # 啟用 Traefik
      - "traefik.enable=true"
      
      # Router: 處理主網域
      - "traefik.http.routers.frontend.rule=Host(`example.com`)"
      - "traefik.http.routers.frontend.entrypoints=websecure"
      - "traefik.http.routers.frontend.tls.certresolver=letsencrypt"
      
      # Service: 前端服務 port
      - "traefik.http.services.frontend.loadbalancer.server.port=80"
      
      # 指定網路（重要！）
      - "traefik.docker.network=traefik-public"
    networks:
      - traefik-public

  # ========================================
  # API Backend
  # ========================================
  api:
    image: api:latest
    labels:
      - "traefik.enable=true"第
      
      # Router: 處理 /api 路徑
      - "traefik.http.routers.api.rule=Host(`example.com`) && PathPrefix(`/api`)"
      - "traefik.http.routers.api.entrypoints=websecure"
      - "traefik.http.routers.api.tls.certresolver=letsencrypt"
      
      # Middleware: 移除 /api 前綴
      - "traefik.http.middlewares.api-stripprefix.stripprefix.prefixes=/api"
      - "traefik.http.routers.api.middlewares=api-stripprefix"
      
      # Service
      - "traefik.http.services.api.loadbalancer.server.port=4000"
      
      # 健康檢查
      - "traefik.http.services.api.loadbalancer.healthcheck.path=/health"
      - "traefik.http.services.api.loadbalancer.healthcheck.interval=10s"
      
      - "traefik.docker.network=traefik-public"
    networks:
      - traefik-public
      - backend

  # ========================================
  # 資料庫（不經過 Traefik）
  # ========================================
  postgres:
    image: postgres:15
    networks:
      - backend  # 只在內部網路

networks:
  traefik-public:
    external: true
  backend:
    internal: true
```

---

## 9.3. 建立全域代理網路 (Proxy Network)

### 為什麼需要全域網路？

**問題：** 多個專案需要共享同一個 Traefik

```
Project A              Project B
┌─────────┐           ┌─────────┐
│  app-a  │           │  app-b  │
└─────────┘           └─────────┘
     ↓                     ↓
     需要共同的 Traefik
```

**解決：** 建立外部網路，讓所有專案連接

---

### 建立全域網路

```bash
# 建立 Traefik 專用網路
docker network create traefik-public

# 查看網路
docker network ls | grep traefik
# abc123...  traefik-public  bridge    local

# 查看詳情
docker network inspect traefik-public
```

---

### Traefik 專案設定

**traefik/docker-compose.yml：**

```yaml
version: '3.8'

services:
  traefik:
    image: traefik:v2.10
    container_name: traefik
    restart: unless-stopped
    
    command:
      # 全域設定
      - "--global.sendanonymoususage=false"
      
      # EntryPoints
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
      - "--entrypoints.websecure.address=:443"
      
      # Docker Provider
      - "--providers.docker=true"
      - "--providers.docker.network=traefik-public"
      - "--providers.docker.exposedbydefault=false"
      
      # SSL/ACME
      - "--certificatesresolvers.letsencrypt.acme.email=admin@example.com"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
      
      # 儀表板
      - "--api.dashboard=true"
      
      # 日誌
      - "--log.level=INFO"
      - "--accesslog=true"
    
    ports:
      - "80:80"
      - "443:443"
    
    volumes:
      # Docker socket（監聽容器事件）
      - /var/run/docker.sock:/var/run/docker.sock:ro
      
      # ACME 憑證儲存
      - ./letsencrypt:/letsencrypt
      
      # 日誌
      - ./logs:/var/log/traefik
    
    networks:
      - traefik-public
    
    labels:
      # 儀表板路由
      - "traefik.enable=true"
      - "traefik.http.routers.dashboard.rule=Host(`traefik.example.com`)"
      - "traefik.http.routers.dashboard.entrypoints=websecure"
      - "traefik.http.routers.dashboard.tls.certresolver=letsencrypt"
      - "traefik.http.routers.dashboard.service=api@internal"
      
      # Basic Auth 保護儀表板
      - "traefik.http.middlewares.dashboard-auth.basicauth.users=admin:$$apr1$$..."
      - "traefik.http.routers.dashboard.middlewares=dashboard-auth"

networks:
  traefik-public:
    external: true  # ← 使用外部網路
```

---

### 應用專案設定

**project-a/docker-compose.yml：**

```yaml
version: '3.8'

services:
  web-a:
    image: app-a:latest
    networks:
      - traefik-public  # ← 連接到全域網路
      - internal       # 也可連接內部網路
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app-a.rule=Host(`app-a.example.com`)"
      - "traefik.http.routers.app-a.entrypoints=websecure"
      - "traefik.http.routers.app-a.tls.certresolver=letsencrypt"
      - "traefik.http.services.app-a.loadbalancer.server.port=80"
      - "traefik.docker.network=traefik-public"  # ← 指定使用哪個網路

  db-a:
    image: postgres:15
    networks:
      - internal  # 不連接 Traefik 網路

networks:
  traefik-public:
    external: true  # ← 使用外部網路
  internal:  # 內部私有網路
```

**project-b/docker-compose.yml：**

```yaml
version: '3.8'

services:
  web-b:
    image: app-b:latest
    networks:
      - traefik-public  # ← 相同的全域網路
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app-b.rule=Host(`app-b.example.com`)"
      - "traefik.http.routers.app-b.entrypoints=websecure"
      - "traefik.http.routers.app-b.tls.certresolver=letsencrypt"
      - "traefik.http.services.app-b.loadbalancer.server.port=3000"
      - "traefik.docker.network=traefik-public"

networks:
  traefik-public:
    external: true
```

---

### 啟動與驗證

```bash
# 1. 建立全域網路
docker network create traefik-public

# 2. 啟動 Traefik
cd traefik
docker-compose up -d

# 3. 啟動 Project A
cd ../project-a
docker-compose up -d

# 4. 啟動 Project B
cd ../project-b
docker-compose up -d

# 5. 驗證路由
curl -H "Host: app-a.example.com" http://localhost
curl -H "Host: app-b.example.com" http://localhost

# 6. 查看 Traefik 儀表板
# 訪問：https://traefik.example.com:8080/dashboard/
```

---

### 查看 Traefik 配置

```bash
# 查看所有路由
docker exec traefik traefik healthcheck

# 查看容器標籤
docker inspect web-a | jq '.[0].Config.Labels'

# 查看網路連接
docker network inspect traefik-public

# 輸出會顯示所有連接到 traefik-public 的容器：
# "Containers": {
#     "traefik": {...},
#     "web-a": {...},
#     "web-b": {...}
# }
```

這樣可以實現多專案共享單一 Traefik 實例！
