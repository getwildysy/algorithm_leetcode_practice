# 11. 網路連線除錯 (Network Troubleshooting)

## 11.1. Gateway Timeout (504) 排查：檢查 Traefik 與應用程式是否在同一個 Docker Network

### 問題場景

**錯誤訊息：**
```
504 Gateway Timeout
The server didn't respond in time.
```

**常見原因：** Traefik 與應用程式不在同一個網路，無法通訊。

```
┌─────────────┐         ┌─────────────┐
│  Traefik    │         │     App     │
│  Network A  │    X    │  Network B  │
└─────────────┘         └─────────────┘
     無法連接
```

---

### 診斷步驟

**步驟 1：檢查容器所屬網路**

```bash
# 查看 Traefik 的網路
docker inspect traefik | jq '.[0].NetworkSettings.Networks | keys'

# 輸出範例：
# [
#   "traefik-public"
# ]

# 查看應用程式的網路
docker inspect app | jq '.[0].NetworkSettings.Networks | keys'

# 輸出範例：
# [
#   "app_default"  ← 問題！與 Traefik 不在同一網路
# ]
```

**步驟 2：查看詳細網路資訊**

```bash
# 列出所有網路
docker network ls

# 查看特定網路的所有容器
docker network inspect traefik-public | jq '.[0].Containers'

# 輸出：
# {
#   "traefik": {
#     "Name": "traefik",
#     "IPv4Address": "172.20.0.2/16"
#   }
# }
# ← 沒有看到 app 容器！
```

**步驟 3：測試網路連通性**

```bash
# 從 Traefik 容器 ping 應用程式
docker exec traefik ping app -c 2

# 失敗輸出：
# ping: bad address 'app'

# 或
# connect: No route to host
```

---

### 解決方案

**方案 1：將應用程式加入 Traefik 網路**

```yaml
services:
  app:
    image: myapp
    networks:
      - traefik-public  # ✅ 加入 Traefik 所在網路
      - app-internal    # 也可保留內部網路
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app.rule=Host(`example.com`)"
      - "traefik.docker.network=traefik-public"  # ✅ 明確指定網路

networks:
  traefik-public:
    external: true
  app-internal:
```

**方案 2：手動連接容器到網路**

```bash
# 將現有容器連接到 traefik-public 網路
docker network connect traefik-public app

# 驗證
docker inspect app | jq '.[0].NetworkSettings.Networks | keys'

# 輸出應包含：
# [
#   "app_default",
#   "traefik-public"  ← ✅ 已加入
# ]
```

**驗證修復：**

```bash
# 從 Traefik ping 應用程式
docker exec traefik ping app -c 2

# 成功輸出：
# PING app (172.20.0.5): 56 data bytes
# 64 bytes from 172.20.0.5: icmp_seq=0 ttl=64 time=0.123 ms
# ✅ 連線成功！

# 測試 HTTP 請求
docker exec traefik curl http://app:4000/health

# 輸出：
# {"status": "healthy"}
```

---

### 常見錯誤配置

**錯誤 1：忘記宣告 external 網路**

```yaml
# ❌ 錯誤
services:
  app:
    networks:
      - traefik-public  # 這會建立新的網路，而不是使用外部網路！

networks:
  traefik-public:  # ← 缺少 external: true
```

```yaml
# ✅ 正確
networks:
  traefik-public:
    external: true  # ← 使用外部網路
```

**錯誤 2：未指定 traefik.docker.network**

```yaml
# ❌ 容器連接到多個網路時的問題
services:
  app:
    networks:
      - traefik-public
      - backend
      - redis
    # ← 缺少 traefik.docker.network 標籤
```

Traefik 不知道該使用哪個網路的 IP！

```yaml
# ✅ 正確
services:
  app:
    networks:
      - traefik-public
      - backend
    labels:
      - "traefik.docker.network=traefik-public"  # ← 明確指定
```

---

## 11.2. Connection Refused 排查：區分容器監聽地址 127.0.0.1 vs 0.0.0.0

### 問題場景

**錯誤訊息：**
```
curl: (7) Failed to connect to app port 4000: Connection refused
```

**原因：** 應用程式只監聽 `127.0.0.1`（localhost），容器外部無法連接。

```
Container
┌───────────────────────────────┐
│  App 監聽 127.0.0.1:4000      │ ← 只有容器內部可以連接
│                               │
│  外部請求 → X Connection refused
└───────────────────────────────┘
```

---

### 診斷步驟

**步驟 1：檢查應用程式監聽地址**

```bash
# 進入容器
docker exec -it app sh

# 查看監聽的 port
netstat -tuln | grep 4000

# ❌ 問題：只監聽 localhost
# tcp    0      0 127.0.0.1:4000    0.0.0.0:*     LISTEN

# ✅ 正確：監聽所有介面
# tcp    0      0 0.0.0.0:4000      0.0.0.0:*     LISTEN
```

**步驟 2：測試連線**

```bash
# 在容器內部測試（應該成功）
docker exec app curl http://127.0.0.1:4000/health

# 從其他容器測試（如果失敗 → 監聽地址問題）
docker exec traefik curl http://app:4000/health
# Connection refused ← 問題確認
```

---

### 解決方案

**Node.js / Express：**

```javascript
// ❌ 錯誤：只監聽 localhost
app.listen(4000, '127.0.0.1', () => {
  console.log('Server listening on 127.0.0.1:4000');
});

// ✅ 正確：監聽所有介面
app.listen(4000, '0.0.0.0', () => {
  console.log('Server listening on 0.0.0.0:4000');
});

// ✅ 或省略 host 參數（預設 0.0.0.0）
app.listen(4000, () => {
  console.log('Server listening on port 4000');
});
```

**Python / Flask：**

```python
# ❌ 錯誤
app.run(host='127.0.0.1', port=5000)

# ✅ 正確
app.run(host='0.0.0.0', port=5000)
```

**Python / FastAPI：**

```python
# ❌ 錯誤
uvicorn.run(app, host="127.0.0.1", port=8000)

# ✅ 正確
uvicorn.run(app, host="0.0.0.0", port=8000)
```

**Go：**

```go
// ❌ 錯誤
http.ListenAndServe("127.0.0.1:8080", nil)

// ✅ 正確
http.ListenAndServe(":8080", nil)  // 等同於 0.0.0.0:8080
```

**Nginx：**

```nginx
# ❌ 錯誤
listen 127.0.0.1:80;

# ✅ 正確
listen 80;  # 預設 0.0.0.0:80
```

---

### 驗證修復

```bash
# 重新建置並啟動容器
docker-compose up -d --build app

# 查看監聽地址
docker exec app netstat -tuln | grep 4000

# 輸出：
# tcp    0      0 0.0.0.0:4000    0.0.0.0:*     LISTEN  ✅

# 從其他容器測試
docker exec traefik curl http://app:4000/health

# 輸出：
# {"status": "healthy"}  ✅ 成功！
```

---

## 11.3. 除錯工具使用：使用 docker network inspect 繪製網路拓撲圖

### docker network inspect 基本用法

```bash
# 查看網路詳細資訊
docker network inspect traefik-public
```

**輸出範例：**

```json
[
  {
    "Name": "traefik-public",
    "Id": "abc123def456...",
    "Driver": "bridge",
    "Scope": "local",
    "IPAM": {
      "Config": [
        {
          "Subnet": "172.20.0.0/16",
          "Gateway": "172.20.0.1"
        }
      ]
    },
    "Containers": {
      "container1_id": {
        "Name": "traefik",
        "IPv4Address": "172.20.0.2/16",
        "MacAddress": "02:42:ac:14:00:02"
      },
      "container2_id": {
        "Name": "app",
        "IPv4Address": "172.20.0.5/16",
        "MacAddress": "02:42:ac:14:00:05"
      }
    }
  }
]
```

---

### 使用 jq 提取關鍵資訊

**1. 列出網路中的所有容器：**

```bash
docker network inspect traefik-public | jq '.[0].Containers | to_entries[] | {name: .value.Name, ip: .value.IPv4Address}'
```

**輸出：**
```json
{
  "name": "traefik",
  "ip": "172.20.0.2/16"
}
{
  "name": "app",
  "ip": "172.20.0.5/16"
}
```

**2. 繪製網路拓撲圖：**

```bash
#!/bin/bash
# network-map.sh

NETWORK=$1

echo "========================================="
echo "Network: $NETWORK"
echo "========================================="

# 取得網路資訊
docker network inspect $NETWORK | jq -r '
  .[0] | 
  "Subnet: \(.IPAM.Config[0].Subnet)",
  "Gateway: \(.IPAM.Config[0].Gateway)",
  "",
  "Containers:"
'

# 列出容器
docker network inspect $NETWORK | jq -r '
  .[0].Containers | 
  to_entries[] | 
  "  ├─ \(.value.Name) (\(.value.IPv4Address))"
'

echo "========================================="
```

**使用：**
```bash
chmod +x network-map.sh
./network-map.sh traefik-public
```

**輸出：**
```
=========================================
Network: traefik-public
=========================================
Subnet: 172.20.0.0/16
Gateway: 172.20.0.1

Containers:
  ├─ traefik (172.20.0.2/16)
  ├─ frontend (172.20.0.3/16)
  ├─ backend (172.20.0.4/16)
  ├─ postgres (172.20.0.5/16)
=========================================
```

---

### 進階除錯指令

**1. 查看容器的所有網路：**

```bash
#!/bin/bash
# container-networks.sh

CONTAINER=$1

echo "Container: $CONTAINER"
echo "Networks:"

docker inspect $CONTAINER | jq -r '
  .[0].NetworkSettings.Networks | 
  to_entries[] | 
  "  ├─ \(.key)"
  "     Gateway: \(.value.Gateway)",
  "     IP: \(.value.IPAddress)",
  "     MAC: \(.value.MacAddress)"
'
```

**2. 測試容器間連通性：**

```bash
#!/bin/bash
# test-connectivity.sh

SOURCE=$1
TARGET=$2

echo "Testing: $SOURCE → $TARGET"

# Ping 測試
echo "1. Ping test:"
docker exec $SOURCE ping -c 2 $TARGET

# DNS 解析測試
echo ""
echo "2. DNS resolution:"
docker exec $SOURCE nslookup $TARGET

# HTTP 測試（如果是 web 服務）
echo ""
echo "3. HTTP test:"
docker exec $SOURCE curl -I http://$TARGET 2>/dev/null | head -1
```

**使用：**
```bash
./test-connectivity.sh traefik app
```

---

### 常用除錯指令集合

```bash
# 1. 查看所有網路
docker network ls

# 2. 查看容器的網路設定
docker inspect <container> | jq '.[0].NetworkSettings'

# 3. 查看容器的 IP 位址
docker inspect <container> | jq -r '.[0].NetworkSettings.Networks | to_entries[] | "\(.key): \(.value.IPAddress)"'

# 4. 查看容器的 DNS 設定
docker inspect <container> | jq '.[0].HostConfig.Dns'

# 5. 查看容器的 Hosts 檔案
docker exec <container> cat /etc/hosts

# 6. 查看容器的路由表
docker exec <container> ip route

# 7. 查看容器的網路介面
docker exec <container> ip addr

# 8. 監聽網路流量（需要 tcpdump）
docker exec <container> tcpdump -i eth0 -n

# 9. 測試 port 連通性
docker exec <container> nc -zv <target> <port>

# 10. 追蹤路由
docker exec <container> traceroute <target>
```

---

### 實戰案例：完整除錯流程

**問題：** Frontend 無法連接到 Backend

**步驟 1：確認網路配置**

```bash
# 查看 frontend 的網路
docker inspect frontend | jq '.[0].NetworkSettings.Networks | keys'
# 輸出：["app-network"]

# 查看 backend 的網路
docker inspect backend | jq '.[0].NetworkSettings.Networks | keys'
# 輸出：["backend-network"]

# ❌ 問題發現：兩者不在同一網路！
```

**步驟 2：查看詳細網路資訊**

```bash
# 查看 app-network 的容器
docker network inspect app-network | jq '.[0].Containers | keys'
# 輸出：["frontend_id"]

# 查看 backend-network 的容器
docker network inspect backend-network | jq '.[0].Containers | keys'
# 輸出：["backend_id"]

# 確認：frontend 和 backend 在不同網路
```

**步驟 3：測試連通性**

```bash
# 從 frontend ping backend
docker exec frontend ping backend -c 2

# 錯誤：ping: bad address 'backend'
# → DNS 無法解析，因為不在同一網路
```

**步驟 4：修復**

```yaml
# docker-compose.yml
services:
  frontend:
    networks:
      - shared-network  # ✅ 使用共同網路

  backend:
    networks:
      - shared-network  # ✅ 使用共同網路

networks:
  shared-network:
```

**步驟 5：驗證修復**

```bash
# 重新啟動
docker-compose up -d

# 再次測試
docker exec frontend ping backend -c 2

# 成功：
# PING backend (172.20.0.5): 56 data bytes
# 64 bytes from 172.20.0.5: icmp_seq=0 ttl=64 time=0.089 ms
# ✅ 問題解決！
```

---

### 網路除錯最佳實踐

1. **✅ 使用一致的網路命名**
   ```yaml
   networks:
     app-network:  # 清楚的名稱
       driver: bridge
   ```

2. **✅ 明確宣告外部網路**
   ```yaml
   networks:
     traefik-public:
       external: true
   ```

3. **✅ 記錄網路拓撲**
   ```bash
   # 定期匯出網路配置
   docker network ls > networks-$(date +%Y%m%d).txt
   docker network inspect traefik-public > traefik-network-$(date +%Y%m%d).json
   ```

4. **✅ 使用健康檢查**
   ```yaml
   healthcheck:
     test: ["CMD", "curl", "-f", "http://backend:4000/health"]
     interval: 10s
   ```

5. **✅ 設定適當的 DNS**
   ```yaml
   services:
     app:
       dns:
         - 8.8.8.8
         - 8.8.4.4
   ```

這樣可以快速診斷並解決 Docker 網路問題！
