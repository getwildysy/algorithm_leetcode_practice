# 7. 服務相依性與啟動順序 (Startup Order)

## 7.1. 競爭條件 (Race Condition)：為什麼 depends_on 還不夠？（後端比資料庫早啟動導致崩潰）

### 問題場景

**錯誤的 Docker Compose 設定：**

```yaml
version: '3.8'

services:
  api:
    image: myapi
    depends_on:
      - postgres  # ← 只保證「啟動順序」
    environment:
      DB_HOST: postgres
      DB_PORT: 5432

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: myapp
```

**啟動流程：**

```bash
docker-compose up -d

# 實際發生的事情：
# 1. ▶ postgres 容器啟動 (0秒)
# 2. ▶ api 容器啟動 (1秒)  ← depends_on 只確保這個順序
# 3. ✅ postgres 開始初始化資料庫 (3秒)
# 4. ❌ api 嘗試連接資料庫 → Connection refused!
# 5. 💀 api 容器崩潰退出
```

**錯誤日誌：**

```
api_1       | Error: connect ECONNREFUSED postgres:5432
api_1       |     at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1148:16)
api_1       | Caused by: Error: Connection refused
api_1 exited with code 1
```

### depends_on 的限制

**`depends_on` 只保證：**
- ✅ 容器的**啟動順序**
- ❌ **不保證** 服務已準備好接受連線

**問題根源：**

```
容器啟動 (Container Start) ≠ 服務就緒 (Service Ready)

PostgreSQL 容器啟動時間軸：
0s:  容器啟動 ✅ (depends_on 認為「完成」)
2s:  PostgreSQL 進程啟動
5s:  初始化資料庫
8s:  資料庫真正準備好接受連線 ✅
```

---

## 7.2. 健康檢查 (Healthchecks)：在 YAML 中撰寫 test 指令確認資料庫真正 Ready

### 基本健康檢查語法

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    healthcheck:
      # 測試指令：檢查 PostgreSQL 是否就緒
      test: ["CMD-SHELL", "pg_isready -U user"]
      
      # 間隔時間：每 10 秒檢查一次
      interval: 10s
      
      # 超時時間：單次檢查最多等待 5 秒
      timeout: 5s
      
      # 重試次數：失敗 5 次才標記為 unhealthy
      retries: 5
      
      # 啟動寬限期：容器啟動後 30 秒才開始檢查
      start_period: 30s
```

### 健康檢查參數詳解

**test（測試指令）：**

```yaml
# 格式 1: Shell 形式
healthcheck:
  test: pg_isready -U user

# 格式 2: Exec 形式（推薦，避免 shell 注入）
healthcheck:
  test: ["CMD", "pg_isready", "-U", "user"]

# 格式 3: Shell 包裝
healthcheck:
  test: ["CMD-SHELL", "pg_isready -U user || exit 1"]
```

**interval（檢查間隔）：**

```yaml
interval: 10s  # 每 10 秒檢查一次

# 建議值：
# - 快速服務（Redis）: 5s
# - 中等服務（API）: 10s-15s
# - 慢速服務（資料庫初始化）: 20s-30s
```

**timeout（單次檢查超時）：**

```yaml
timeout: 5s  # 單次檢查最多等 5 秒

# 太短：可能誤判為 unhealthy
# 太長：拖慢整體啟動時間
```

**retries（重試次數）：**

```yaml
retries: 5  # 連續失敗 5 次才判定為 unhealthy

# 計算方式：
# 最多等待時間 = interval × retries
# 範例: 10s × 5 = 50s
```

**start_period（啟動寬限期）：**

```yaml
start_period: 30s  # 前 30 秒的失敗不計入 retries

# 用途：給服務足夠的初始化時間
# PostgreSQL 初始化通常需要 10-30 秒
```

---

### 常見服務的健康檢查

**1. PostgreSQL**

```yaml
postgres:
  image: postgres:15
  healthcheck:
    test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
    interval: 10s
    timeout: 5s
    retries: 5
    start_period: 30s
```

**2. MySQL/MariaDB**

```yaml
mysql:
  image: mysql:8
  healthcheck:
    test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD}"]
    interval: 10s
    timeout: 5s
    retries: 5
    start_period: 30s
```

**3. MongoDB**

```yaml
mongodb:
  image: mongo:7
  healthcheck:
    test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
    interval: 10s
    timeout: 5s
    retries: 3
    start_period: 20s
```

**4. Redis**

```yaml
redis:
  image: redis:7-alpine
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 5s
    timeout: 3s
    retries: 3
    start_period: 5s
```

**5. Nginx**

```yaml
nginx:
  image: nginx:alpine
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost/health"]
    # 或使用 wget
    # test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
    interval: 30s
    timeout: 3s
    retries: 3
    start_period: 10s
```

**6. Node.js API**

```yaml
api:
  build: ./api
  healthcheck:
    test: ["CMD", "node", "healthcheck.js"]
    # 或使用 curl
    # test: ["CMD", "curl", "-f", "http://localhost:4000/health"]
    interval: 15s
    timeout: 5s
    retries: 3
    start_period: 40s
```

**healthcheck.js 範例：**

```javascript
// healthcheck.js
const http = require('http');

const options = {
  host: 'localhost',
  port: 4000,
  path: '/health',
  timeout: 2000
};

const request = http.request(options, (res) => {
  console.log(`STATUS: ${res.statusCode}`);
  if (res.statusCode === 200) {
    process.exit(0);  // 健康
  } else {
    process.exit(1);  // 不健康
  }
});

request.on('error', (err) => {
  console.error('ERROR:', err.message);
  process.exit(1);
});

request.end();
```

**7. Python/FastAPI**

```yaml
fastapi:
  build: ./api
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
    interval: 15s
    timeout: 5s
    retries: 3
    start_period: 30s
```

**FastAPI 健康端點：**

```python
# main.py
from fastapi import FastAPI
from fastapi.responses import JSONResponse

app = FastAPI()

@app.get("/health")
async def health():
    return JSONResponse({"status": "healthy"}, status_code=200)
```

---

### 查看健康檢查狀態

```bash
# 查看所有容器的健康狀態
docker ps

# 輸出範例：
# CONTAINER ID   IMAGE          STATUS
# abc123...      postgres:15    Up 2 minutes (healthy)
# def456...      myapi          Up 1 minute (health: starting)
# ghi789...      redis:7        Up 30 seconds (unhealthy)

# 查看詳細健康檢查資訊
docker inspect postgres | jq '.[0].State.Health'

# 輸出範例：
# {
#   "Status": "healthy",
#   "FailingStreak": 0,
#   "Log": [
#     {
#       "Start": "2024-12-12T10:00:00Z",
#       "End": "2024-12-12T10:00:01Z",
#       "ExitCode": 0,
#       "Output": "/var/run/postgresql:5432 - accepting connections"
#     }
#   ]
# }

# 使用 docker-compose 查看
docker-compose ps

# 輸出：
# Name                 State              Ports
# project_postgres_1   Up (healthy)      5432/tcp
# project_api_1        Up (healthy)      4000/tcp
```

---

## 7.3. 完整解決方案：結合 depends_on 與 condition: service_healthy 確保完美啟動順序

### Docker Compose 3.8+ 完整範例

```yaml
version: '3.8'

services:
  # ========================================
  # 資料庫層
  # ========================================
  postgres:
    image: postgres:15-alpine
    container_name: db
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d:ro
    networks:
      - db-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  redis:
    image: redis:7-alpine
    container_name: cache
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - db-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 3
      start_period: 10s

  # ========================================
  # 應用層
  # ========================================
  api:
    build:
      context: ./backend
    container_name: api
    environment:
      NODE_ENV: production
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: ${DB_NAME}
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      REDIS_URL: redis://redis:6379
    networks:
      - db-network
      - app-network
    depends_on:
      postgres:
        condition: service_healthy  # ← 等待 postgres 健康
      redis:
        condition: service_healthy  # ← 等待 redis 健康
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4000/health"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 40s

  # ========================================
  # 前端層
  # ========================================
  web:
    build:
      context: ./frontend
    container_name: web
    networks:
      - app-network
    depends_on:
      api:
        condition: service_healthy  # ← 等待 API 健康
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--spider", "http://localhost"]
      interval: 30s
      timeout: 3s
      retries: 3

  # ========================================
  # 反向代理
  # ========================================
  nginx:
    image: nginx:alpine
    container_name: nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    networks:
      - app-network
    depends_on:
      web:
        condition: service_healthy
      api:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 3s
      retries: 3

networks:
  db-network:
    internal: true  # 資料庫網路isolated
  app-network:

volumes:
  postgres_data:
  redis_data:
```

### 啟動順序驗證

```bash
# 啟動所有服務
docker-compose up -d

# 觀察啟動順序
docker-compose logs -f

# 預期輸出：
# postgres_1 | ... database system is ready to accept connections
# postgres_1 | ... (healthy)
# redis_1    | Ready to accept connections
# redis_1    | ... (healthy)
# api_1      | Starting...
# api_1      | Connected to database ✅
# api_1      | Connected to Redis ✅
# api_1      | ... (healthy)
# web_1      | Starting...
# web_1      | API available ✅
# web_1      | ... (healthy)
# nginx_1    | Starting...
# nginx_1    | Upstream web: healthy ✅
# nginx_1    | Upstream api: healthy ✅
```

---

### 處理健康檢查失敗的容器

**自動重啟策略：**

```yaml
services:
  api:
    restart: unless-stopped  # 容器因健康檢查失敗而停止時會重啟
    # 或
    restart: on-failure  # 只在失敗時重啟
    # 或
    restart: always  # 總是重啟
```

**結合健康檢查與重啟策略：**

```yaml
api:
  restart: on-failure
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:4000/health"]
    interval: 30s
    retries: 3
  deploy:
    restart_policy:
      condition: on-failure
      delay: 5s
      max_attempts: 3
      window: 120s
```

---

### 使用 wait-for-it 腳本（替代方案）

如果無法使用 `condition: service_healthy`（舊版 Docker Compose），可以使用等待腳本：

**wait-for-it.sh：**

```bash
#!/bin/sh
# wait-for-it.sh

set -e

host="$1"
shift
port="$1"
shift
cmd="$@"

echo "Waiting for $host:$port..."

until nc -z "$host" "$port"; do
  echo "  $host:$port is unavailable - sleeping"
  sleep 1
done

echo "  $host:$port is up - executing command"
exec $cmd
```

**Dockerfile：**

```dockerfile
FROM node:18-alpine

# 安裝 netcat（用於 wait-for-it.sh）
RUN apk add --no-cache netcat-openbsd

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
COPY wait-for-it.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/wait-for-it.sh

CMD ["node", "server.js"]
```

**docker-compose.yml：**

```yaml
services:
  api:
    build: ./backend
    command: wait-for-it.sh postgres 5432 -- node server.js
    depends_on:
      - postgres
```

---

### 多資料庫依賴範例

```yaml
services:
  api:
    build: ./api
    depends_on:
      postgres:
        condition: service_healthy
      mysql:
        condition: service_healthy
      mongodb:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "node", "healthcheck.js"]
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 60s  # 需要更長的啟動時間

  postgres:
    image: postgres:15
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s

  mysql:
    image: mysql:8
    healthcheck:
      test: ["CMD", "mysqladmin", "ping"]
      interval: 10s

  mongodb:
    image: mongo:7
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s

  redis:
    image: redis:7
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
```

---

### 健康檢查最佳實踐

1. **✅ 設定合理的 start_period**
   ```yaml
   # 資料庫初始化通常需要 20-40 秒
   start_period: 30s
   ```

2. **✅ 使用輕量的健康檢查指令**
   ```yaml
   # 好：快速簡單
   test: ["CMD", "pg_isready"]
   
   # 不好：太複雜
   test: ["CMD-SHELL", "psql -U user -c 'SELECT COUNT(*) FROM users;'"]
   ```

3. **✅ 設定適當的 interval**
   ```yaml
   # 開發環境：快速反饋
   interval: 5s
   
   # 生產環境：降低負載
   interval: 30s
   ```

4. **✅ 提供專用的健康檢查 API**
   ```javascript
   // 檢查所有依賴
   app.get('/health', async (req, res) => {
     const checks = {
       database: await checkDatabase(),
       redis: await checkRedis(),
       disk: await checkDiskSpace()
     };
     
     const isHealthy = Object.values(checks).every(v => v === true);
     res.status(isHealthy ? 200 : 503).json(checks);
   });
   ```

5. **✅ 記錄健康檢查日誌**
   ```yaml
   healthcheck:
     test: ["CMD-SHELL", "curl -f http://localhost/health 2>&1 | tee /var/log/healthcheck.log"]
   ```

這樣可以確保服務以正確的順序啟動，避免競爭條件！
