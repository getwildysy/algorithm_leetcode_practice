# 8. 資料庫初始化與持久化

## 8.1. Init Scripts：利用 /docker-entrypoint-initdb.d 自動建立資料表與使用者

### 資料庫初始化機制

Docker 官方資料庫映像檔（PostgreSQL, MySQL, MongoDB）提供了**自動執行初始化腳本**的機制：

**執行時機：**
- 只在**第一次啟動**且**資料目錄為空**時執行
- 容器重啟不會再次執行

**支援的檔案類型：**
- `.sh` - Shell 腳本
- `.sql` - SQL 腳本（PostgreSQL/MySQL）
- `.sql.gz` - 壓縮的 SQL 腳本
- `.js` - JavaScript 腳本（MongoDB）

**執行順序：**
- 按檔名**字母順序**執行
- 建議使用數字前綴：`01-schema.sql`, `02-data.sql`

---

### PostgreSQL 初始化範例

**專案結構：**

```
project/
├── docker-compose.yml
├── postgres/
│   └── init-scripts/
│       ├── 01-create-database.sql
│       ├── 02-create-schema.sql
│       ├── 03-create-tables.sql
│       ├── 04-insert-seed-data.sql
│       └── 05-create-functions.sql
└── .env
```

**docker-compose.yml：**

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: postgres
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    volumes:
      # 資料持久化
      - postgres_data:/var/lib/postgresql/data
      
      # 掛載初始化腳本（唯讀）
      - ./postgres/init-scripts:/docker-entrypoint-initdb.d:ro
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
```

**01-create-database.sql：**

```sql
-- 建立額外的資料庫
CREATE DATABASE app_test;
CREATE DATABASE app_analytics;

-- 建立使用者
CREATE USER app_user WITH PASSWORD 'user123';
CREATE USER readonly_user WITH PASSWORD 'readonly123';

-- 授予權限
GRANT ALL PRIVILEGES ON DATABASE myapp TO app_user;
GRANT CONNECT ON DATABASE myapp TO readonly_user;

-- 切換到主要資料庫
\c myapp

-- 為 readonly_user 設定唯讀權限
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readonly_user;
```

**02-create-schema.sql：**

```sql
-- 建立 schema
CREATE SCHEMA IF NOT EXISTS app;
CREATE SCHEMA IF NOT EXISTS audit;

-- 設定搜尋路徑
ALTER DATABASE myapp SET search_path TO app, public;
```

**03-create-tables.sql：**

```sql
-- 切換到 app schema
SET search_path TO app, public;

-- 建立使用者表
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 建立文章表
CREATE TABLE IF NOT EXISTS posts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    published BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 建立索引
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_published ON posts(published);
CREATE INDEX idx_users_email ON users(email);

-- 建立更新時間觸發器
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_posts_updated_at
    BEFORE UPDATE ON posts
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

**04-insert-seed-data.sql：**

```sql
SET search_path TO app, public;

-- 插入測試使用者
INSERT INTO users (username, email, password_hash) VALUES
    ('admin', 'admin@example.com', '$2b$10$abcdefghijklmnopqrstuvwxyz'),
    ('testuser', 'test@example.com', '$2b$10$1234567890abcdefghijklmn'),
    ('demo', 'demo@example.com', '$2b$10$zyxwvutsrqponmlkjihgfed')
ON CONFLICT (username) DO NOTHING;

-- 插入測試文章
INSERT INTO posts (user_id, title, content, published) VALUES
    (1, '歡迎使用本系統', '這是第一篇文章', TRUE),
    (1, 'Docker 教學', 'Docker 是一個容器化平台...', TRUE),
    (2, '測試文章', '這是測試內容', FALSE)
ON CONFLICT DO NOTHING;

-- 建立審計日誌表
CREATE TABLE IF NOT EXISTS audit.logs (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(50),
    operation VARCHAR(10),
    user_id INTEGER,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    old_values JSONB,
    new_values JSONB
);

-- 印出初始化完成訊息
DO $$
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Database initialization completed!';
    RAISE NOTICE '  - Users created: %', (SELECT COUNT(*) FROM users);
    RAISE NOTICE '  - Posts created: %', (SELECT COUNT(*) FROM posts);
    RAISE NOTICE '========================================';
END $$;
```

---

### MySQL 初始化範例

**docker-compose.yml：**

```yaml
services:
  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQLDATABASE: ${DB_NAME}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./mysql/init-scripts:/docker-entrypoint-initdb.d:ro
    command: >
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_unicode_ci
      --default-authentication-plugin=mysql_native_password
```

**01-init.sql：**

```sql
-- 建立資料庫
CREATE DATABASE IF NOT EXISTS myapp CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE myapp;

-- 建立使用者表
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 建立索引
CREATE INDEX idx_email ON users(email);

-- 插入初始資料
INSERT INTO users (username, email, password_hash) VALUES
    ('admin', 'admin@example.com', '$2b$10$abc123...'),
    ('user1', 'user1@example.com', '$2b$10$def456...');

-- 建立預存程序
DELIMITER $$
CREATE PROCEDURE GetUserByEmail(IN user_email VARCHAR(255))
BEGIN
    SELECT * FROM users WHERE email = user_email;
END$$
DELIMITER ;

-- 授予權限
GRANT SELECT, INSERT, UPDATE, DELETE ON myapp.* TO '${DB_USER}'@'%';
FLUSH PRIVILEGES;

SELECT 'Database initialization completed!' AS message;
```

---

### MongoDB 初始化範例

**docker-compose.yml：**

```yaml
services:
  mongodb:
    image: mongo:7
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USER}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
      MONGO_INITDB_DATABASE: ${MONGO_DB}
    volumes:
      - mongodb_data:/data/db
      - ./mongodb/init-scripts:/docker-entrypoint-initdb.d:ro
```

**01-init.js：**

```javascript
// 連接到資料庫
db = db.getSiblingDB('myapp');

// 建立使用者
db.createUser({
  user: 'app_user',
  pwd: 'user123',
  roles: [
    { role: 'readWrite', db: 'myapp' }
  ]
});

// 建立集合
db.createCollection('users');
db.createCollection('posts');

// 建立索引
db.users.createIndex({ email: 1 }, { unique: true });
db.users.createIndex({ username: 1 }, { unique: true });
db.posts.createIndex({ user_id: 1 });
db.posts.createIndex({ created_at: -1 });

// 插入初始資料
db.users.insertMany([
  {
    username: 'admin',
    email: 'admin@example.com',
    password_hash: '$2b$10$abc123...',
    role: 'admin',
    created_at: new Date()
  },
  {
    username: 'user1',
    email: 'user1@example.com',
    password_hash: '$2b$10$def456...',
    role: 'user',
    created_at: new Date()
  }
]);

db.posts.insertMany([
  {
    user_id: ObjectId(),
    title: '第一篇文章',
    content: '內容...',
    published: true,
    created_at: new Date()
  }
]);

// 印出統計資訊
print('========================================');
print('MongoDB initialization completed!');
print('  - Users:', db.users.countDocuments());
print('  - Posts:', db.posts.countDocuments());
print('========================================');
```

---

### 使用 Shell 腳本進行複雜初始化

**05-advanced-setup.sh：**

```bash
#!/bin/bash
set -e

# 這個腳本會在所有 .sql 檔案執行後執行

echo "執行進階設定..."

# 執行複雜的 SQL 指令
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    -- 建立分區表
    CREATE TABLE logs_2024 PARTITION OF logs
        FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

    -- 建立物化視圖
    CREATE MATERIALIZED VIEW user_stats AS
        SELECT user_id, COUNT(*) as post_count
        FROM posts
        GROUP BY user_id;

    CREATE INDEX ON user_stats (user_id);
EOSQL

# 匯入大型資料檔案
if [ -f /data/large-dataset.sql.gz ]; then
    echo "匯入大型資料集..."
    gunzip -c /data/large-dataset.sql.gz | psql -U "$POSTGRES_USER" -d "$POSTGRES_DB"
fi

# 執行資料驗證
psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT COUNT(*) FROM users;"

echo "進階設定完成！"
```

---

### 驗證初始化是否成功

```bash
# 查看容器日誌
docker-compose logs postgres

# 應該看到：
# postgres_1 | ... PostgreSQL init process complete; ready for start up.
# postgres_1 | ... Database initialization completed!

# 進入容器檢查
docker-compose exec postgres psql -U myuser -d myapp

# 查看資料表
\dt

# 查看資料
SELECT * FROM users;
SELECT * FROM posts;

# 查看使用者權限
\du
```

---

## 8.2. Volume 策略：區分「程式碼掛載 (Bind Mount)」與「資料庫儲存 (Named Volume)」

### Volume 類型比較

| 類型 | 語法 | 位置 | 適用場景 | 效能 |
|------|------|------|---------|------|
| **Named Volume** | `volume_name:/path` | Docker 管理 | 資料庫、日誌 | 高 |
| **Bind Mount** | `./host/path:/container/path` | 主機路徑 | 開發熱更新 | 中 |
| **tmpfs Mount** | `tmpfs:/path` | 記憶體 | 快取、暫存 | 極高 |

---

### Named Volume（命名卷）

**特性：**
- ✅ Docker 統一管理
- ✅ 效能最佳（特別是 Mac/Windows）
- ✅ 跨容器共享
- ✅ 備份/遷移方便
- ❌ 不容易直接存取檔案

**適用場景：**
- 資料庫資料
- 日誌檔案
- 應用程式上傳的檔案
- 生產環境資料持久化

**範例：**

```yaml
services:
  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data  # ← Named Volume

  redis:
    image: redis:7
    volumes:
      - redis_data:/data

  app:
    image: myapp
    volumes:
      - app_uploads:/app/uploads  # 使用者上傳檔案
      - app_logs:/var/log/app      # 應用程式日誌

volumes:
  postgres_data:      # ← 宣告 Named Volume
    driver: local
  redis_data:
  app_uploads:
  app_logs:
```

**進階設定：**

```yaml
volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/data/postgres  # 指定主機路徑

  redis_data:
    driver: local
    driver_opts:
      type: nfs
      o: addr=192.168.1.100,rw
      device: ":/path/to/nfs
/redis"  # NFS 網路儲存
```

**管理 Named Volume：**

```bash
# 列出所有 volumes
docker volume ls

# 查看特定 volume 詳情
docker volume inspect project_postgres_data

# 輸出：
# [
#     {
#         "Name": "project_postgres_data",
#         "Driver": "local",
#         "Mountpoint": "/var/lib/docker/volumes/project_postgres_data/_data",
#         "Scope": "local"
#     }
# ]

# 備份 volume
docker run --rm \
  -v project_postgres_data:/data \
  -v $(pwd):/backup \
  alpine tar czf /backup/postgres-backup.tar.gz -C /data .

# 還原 volume
docker run --rm \
  -v project_postgres_data:/data \
  -v $(pwd):/backup \
  alpine tar xzf /backup/postgres-backup.tar.gz -C /data

# 刪除 volume（危險！）
docker volume rm project_postgres_data

# 清理未使用的 volumes
docker volume prune
```

---

### Bind Mount（綁定掛載）

**特性：**
- ✅ 直接存取主機檔案
- ✅ 實時同步（熱更新）
- ✅ 方便開發除錯
- ❌ 效能較差（Mac/Windows）
- ❌ 路徑依賴主機環境

**適用場景：**
- 開發環境程式碼熱更新
- 設定檔掛載
- 初始化腳本
- 開發工具（不需持久化）

**範例：**

```yaml
services:
  # 開發環境：掛載原始碼
  frontend-dev:
    image: node:18
    volumes:
      - ./frontend/src:/app/src:cached     # 原始碼（主機寫入優先）
      - ./frontend/public:/app/public:ro   # 靜態檔案（唯讀）
      - /app/node_modules                  # 排除（使用容器的版本）
    working_dir: /app
    command: npm run dev

  # Nginx：掛載設定檔
  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/sites:/etc/nginx/conf.d:ro
      - ./ssl/certs:/etc/nginx/ssl:ro

  # 資料庫：掛載初始化腳本
  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 資料用 Named Volume
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/01-init.sql:ro  # 腳本用 Bind Mount
```

**權限設定：**

```yaml
volumes:
  # :ro - 唯讀（容器無法修改）
  - ./config:/app/config:ro

  # :rw - 讀寫（預設）
  - ./logs:/app/logs:rw

  # :z - SELinux 共享標籤
  - ./data:/app/data:z

  # :Z - SELinux 私有標籤
  - ./secrets:/app/secrets:Z

  # cached - 主機寫入優先（Mac/Windows 效能優化）
  - ./src:/app/src:cached

  # delegated - 容器寫入優先
  - ./output:/app/output:delegated
```

---

### 混合策略（最佳實踐）

```yaml
version: '3.8'

services:
  # ========================================
  # 資料庫：使用 Named Volume
  # ========================================
  postgres:
    image: postgres:15
    volumes:
      # 資料：Named Volume（效能最佳）
      - postgres_data:/var/lib/postgresql/data
      
      # 初始化腳本：Bind Mount（方便修改）
      - ./postgres/init:/docker-entrypoint-initdb.d:ro
      
      # 設定檔：Bind Mount
      - ./postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro

  # ========================================
  # 應用程式
  # ========================================
  app:
    build: ./app
    volumes:
      # 上傳檔案：Named Volume（持久化）
      - app_uploads:/app/uploads
      
      # 日誌：Named Volume（持久化）
      - app_logs:/var/log/app
      
      # 快取：tmpfs（記憶體，不持久化）
      - type: tmpfs
        target: /app/cache
        tmpfs:
          size: 100M

      # 開發環境：掛載原始碼（條件式）
      # - ./app/src:/app/src:cached  # 取消註解以啟用熱更新

  # ========================================
  # Redis：記憶體 + 持久化
  # ========================================
  redis:
    image: redis:7-alpine
    volumes:
      # AOF/RDB 持久化
      - redis_data:/data
      
      # Redis 設定
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
    command: redis-server /usr/local/etc/redis/redis.conf

# ========================================
# Volume 宣告
# ========================================
volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/database/postgres  # 掛載到專用磁碟
  
  redis_data:
    driver: local
  
  app_uploads:
    driver: local
    driver_opts:
      type: nfs  # 使用 NFS（多機共享）
      o: addr=192.168.1.100,rw
      device: ":/exports/app-uploads"
  
  app_logs:
    driver: local
```

---

### 備份與還原策略

**資料庫備份：**

```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="./backups"
DATE=$(date +%Y%m%d_%H%M%S)

# PostgreSQL 備份
docker-compose exec -T postgres pg_dump \
  -U myuser \
  -d myapp \
  --clean \
  --if-exists \
  > "$BACKUP_DIR/postgres_$DATE.sql"

# 打包 Volume
docker run --rm \
  -v project_postgres_data:/data:ro \
  -v $(pwd)/backups:/backup \
  alpine tar czf /backup/postgres_volume_$DATE.tar.gz -C /data .

echo "Backup completed: $DATE"
```

**還原：**

```bash
#!/bin/bash
# restore.sh

BACKUP_FILE=$1

# 停止應用（避免資料衝突）
docker-compose stop app

# 還原資料庫
docker-compose exec -T postgres psql -U myuser -d myapp < "$BACKUP_FILE"

# 或還原整個 Volume
docker run --rm \
  -v project_postgres_data:/data \
  -v $(pwd)/backups:/backup \
  alpine tar xzf /backup/postgres_volume_latest.tar.gz -C /data

# 重啟服務
docker-compose up -d

echo "Restore completed"
```

**自動化備份（Cron）：**

```bash
# 編輯 crontab
crontab -e

# 每天凌晨 2 點備份
0 2 * * * /path/to/backup.sh >> /var/log/docker-backup.log 2>&1

# 每週日刪除 30 天前的備份
0 3 * * 0 find /path/to/backups -name "*.sql" -mtime +30 -delete
```

---

### 開發環境 vs 生產環境

**docker-compose.dev.yml（開發）：**

```yaml
services:
  app:
    volumes:
      # 開發：掛載程式碼
      - ./app/src:/app/src:cached
      - ./app/public:/app/public:cached
      - /app/node_modules  # 排除
      
      # 開發：使用本地資料夾方便查看
      - ./data/uploads:/app/uploads
      - ./logs:/var/log/app

  postgres:
    volumes:
      # 開發：使用本地資料夾方便重置
      - ./data/postgres:/var/lib/postgresql/data
    ports:
      - "5432:5432"  # 開發環境暴露 port
```

**docker-compose.prod.yml（生產）：**

```yaml
services:
  app:
    # 生產：不掛載程式碼（已打包在映像檔中）
    volumes:
      # 只掛載必要的資料 volumes
      - app_uploads:/app/uploads
      - app_logs:/var/log/app

  postgres:
    volumes:
      # 生產：使用 Named Volume
      - postgres_data:/var/lib/postgresql/data
    # 生產環境不暴露 port
    # ports: []

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/data/postgres  # 專用磁碟分區
```

這樣可以確保資料安全且效能最佳！
