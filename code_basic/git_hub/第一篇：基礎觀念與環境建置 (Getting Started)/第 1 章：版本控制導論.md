# 第 1 章：版本控制導論

## 1.1 為什麼需要版本控制？（解決「最終版_v2_真的最後版.doc」的問題）

在沒有版本控制系統（Version Control System, VCS）的年代，或是尚未習慣使用 VCS 的團隊，最常見的噩夢就是檔案命名地獄。你可能在電腦看過這種檔案列表：

*   `Proposal.doc`
*   `Proposal_final.doc`
*   `Proposal_final_v2.doc`
*   `Proposal_final_really_last_one.doc`
*   `Proposal_final_FINAL_BOSS_DO_NOT_TOUCH.doc`

這種「人工版本控制」有幾個致命缺點：
1.  **不知道改了什麼**：你無法快速比較 `v2` 和 `v3` 之間具體改了哪一行程式碼或文字。
2.  **不敢刪檔案**：因為怕將來可能會用到舊版，導致專案資料夾越來越肥大。
3.  **無法多人協作**：如果兩個人同時修改同一個檔案，最後只能用「覆蓋」的方式解決，這會導致其中一人的心血付諸流水。
4.  **缺乏上下文**：你不知道為什麼要改這個變數，是修 Bug？還是新功能？

**版本控制系統（VCS）** 的出現就是為了拯救我們。它就像是檔案系統的「時光機」，能記錄檔案的每一次變動（Commit）。使用 VCS，你可以：
*   隨時「回溯」到過去任何一個時間點的狀態。
*   清楚知道「誰」在「什麼時候」改了「什麼內容」以及「為什麼」（Log & Blame）。
*   多人同時修改同一個專案而不互相覆蓋（Merge）。

---

## 1.2 集中式 (CVCS) vs. 分散式 (DVCS) 版本控制系統

了解版本控制後，我們需要知道目前主流的兩種架構差異。

### 集中式版本控制 (Centralized VCS, CVCS)
代表工具：**SVN (Subversion)**, CVS, Perforce

*   **架構**：有一個中央伺服器存放所有檔案版本。工程師工作時，從伺服器 Check out 檔案，改完後 Commit 回伺服器。
*   **優點**：管理員可以輕鬆掌控每個人的權限；只需維護一個中央資料庫。
*   **缺點 (致命傷)**：
    *   **單點故障 (Single Point of Failure)**：如果中央伺服器壞了，所有人都不能工作（不能提交、不能看歷史紀錄）。如果伺服器磁碟壞了且沒備份，所有歷史紀錄就會永久遺失。
    *   **必須連網**：大部分操作都需要連接到中央伺服器。

```mermaid
graph TD
    Server[中央伺服器 (Server)]
    UserA[開發者 A]
    UserB[開發者 B]
    
    UserA -- checkout/commit --> Server
    UserB -- checkout/commit --> Server
    
    style Server fill:#f9f,stroke:#333,stroke-width:2px
```

### 分散式版本控制 (Distributed VCS, DVCS)
代表工具：**Git**, Mercurial

*   **架構**：**沒有絕對的中央伺服器**（雖然實務上會有 GitHub 當作中心，但架構上是對等的）。
*   **每一次 Clone 都是一次完整的備份**。當你把遠端專案 Clone 下來時，你不僅是下載了最新的檔案，你是把**整個專案的歷史紀錄**都完整複製到你的電腦上。
*   **優點**：
    *   **安全性極高**：如果 GitHub 當機了，或是公司伺服器燒毀了，任何一位工程師電腦裡的 Repository 都可以拿出來當作新的伺服器，因為大家都有完整的備份。
    *   **離線工作**：你可以在飛機上、沒網路的地方進行 Commit、開 Branch、看 Logs。等到有網路時再 Push 出去即可。
    *   **分支 (Branch) 成本極低**：Git 鼓勵頻繁使用分支，這改變了現代軟體開發的工作流 (Workflow)。
*   **缺點**：
    *   學習曲線較陡峭（概念較多，如 Staging Area, Local/Remote Repo 等）。
    *   專案歷史極其龐大時，Clone 可能會花一點時間（但 Git 有優化這部分，如 Shallow Clone）。


```mermaid
graph TD
    Server[GitHub / GitLab (遠端)]
    UserA[開發者 A (本機)]
    UserB[開發者 B (本機)]
    
    UserA -- Push / Pull --> Server
    UserB -- Push / Pull --> Server
    
    UserA <.-> UserB : 理論上也可以互相 Push/Pull (P2P)
    
    subgraph ComputerA [電腦 A]
    UserA -- Commit --> LocalRepoA[完整儲存庫 A]
    end
    
    subgraph ComputerB [電腦 B]
    UserB -- Commit --> LocalRepoB[完整儲存庫 B]
    end
    
    style Server fill:#bbf,stroke:#333,stroke-width:2px
    style LocalRepoA fill:#bfb
    style LocalRepoB fill:#bfb
```

> **結論**：Git 屬於分散式版本控制系統，這是它目前統治軟體開發界的主要原因。

---

## 1.3 Git 與 GitHub 的區別（工具 vs. 平台）

許多初學者容易搞混這兩個名詞，以為它們是同一個東西。

| 特性 | **Git** | **GitHub** (或 GitLab, Bitbucket) |
| :--- | :--- | :--- |
| **定義** | 版本控制 **軟體/工具** | 程式碼 **託管平台/網站** |
| **運作位置** | 在你的電腦本機 (Local) 執行 | 在雲端 (Remote) 運行 |
| **是否需網路** | **不需要**。沒網路也能 Commit, Branch | **因為是網站，當然需要網路** |
| **功能核心** | 記錄變更、時光機、合併分支 | 社交協作、Issue 追蹤、PR Code Review |
| **比喻** | 像是 **Word** (編輯工具) | 像是 **Google Drive** (雲端儲存與分享) |
| **比喻 2** | 像是 **MP3 檔案格式/播放器** | 像是 **Spotify/SoundCloud** (音樂分享平台) |

*   **Git** 是讓你管理程式碼修改歷史的工具。
*   **GitHub** 是讓你把用 Git 管理的專案上傳上去，讓別人可以看到、下載、並協助改善的地方。它是建立在 Git 之上的「社群」與「協作平台」。

### 常見術語表 (Terminology)

| 術語 | 英文 | 解釋 |
| :--- | :--- | :--- |
| **Repository (Repo)** | 儲存庫 | 存放專案程式碼與歷史紀錄的地方 (即 `.git` 資料夾)。 |
| **Clone** | 複製 | 從遠端將整個 Repository 下載到本機。 |
| **Commit** | 提交 | 將修改記錄成一個「版本」(存檔)。 |
| **Branch** | 分支 | 獨立的開發線，互不影響。 |
| **Merge** | 合併 | 將兩條分支的修改融合在一起。 |
| **Push** | 推送 | 上傳你的 Commits 到遠端。 |
| **Pull** | 拉取 | 下載遠端的 Commits 並合併到本機。 |
