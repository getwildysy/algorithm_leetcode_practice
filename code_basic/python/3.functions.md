# 一、enumerate

1. 功能:在迴圈中，同時給你「目前的索引（第幾個）」和「目前的資料（內容）」。
2. enumerate 的運作原理:

   enumerate 的英文原意是「列舉」或「數數」。當你把它用在一個列表上時，它會吐出一組組的 Tuple (元組)。

假設 nums = [100, 200, 300]，enumerate(nums) 實際上產生的是這樣的資料流： (0, 100) -> (1, 200) -> (2, 300)

這就是為什麼我們在 for 迴圈開頭要寫兩個變數來接它：

```python
for index, value in enumerate(nums): # ...
```

這叫做「解包 (Unpacking)」，把 Tuple (0, 100) 分別拆給 index 和 value。

3. 範例

```python
fruits = ["蘋果", "香蕉", "橘子"]

for i, fruit in enumerate(fruits):
    print(f"第 {i} 個水果是 {fruit}")
```

4.  enumerate 和 zip
    當有兩個（或更多）列表，而且你同時需要知道：
    資料內容（來自多個列表）
    目前的順序（索引 index）
    這時候將 enumerate 包在 zip 外面是最完美的解法。

(1). 核心概念圖解
想像你有兩個列表：names (名字) 和 scores (分數)。

zip 的工作：把兩個列表像是拉鍊一樣扣在一起，變成一組一組的 (名字, 分數)。

enumerate 的工作：幫每一組資料貼上號碼牌 (0, 1, 2...)。

(2). 程式碼寫法
這裡有一個小細節要注意，就是括號的使用（解包）。

範例情境：列印學生的排名、姓名與分數

```python
names = ["Alice", "Bob", "Charlie"]
scores = [85, 92, 78]

# 寫法：注意 for 迴圈裡的括號 (name, score)
for i, (name, score) in enumerate(zip(names, scores)):
    print(f"第 {i+1} 名: {name} 考了 {score} 分")

```

(3). 語法拆解（為什麼要加括號？）
為什麼寫成 for i, (name, score) 而不是 for i, name, score？

這是因為資料結構長這樣：

zip(names, scores) 產生的是： ('Alice', 85), ('Bob', 92)... (這是一個 Tuple)

enumerate(...) 再加上索引，變成： (0, ('Alice', 85))

(4). zip 有一個特性：如果兩個列表長度不一樣，它會以「短」的那個為準，多出來的會被切掉。

(5).「列表長度不一樣」時該怎麼處理嗎？（例如使用 zip_longest）

zip_longest 會**「以長的為準」。它會堅持跑到最長列表的最後一個元素，至於短缺的部分，它會用一個預設值 (fillvalue)** 來填補。

你需要先匯入它： from itertools import zip_longest

實作範例

```python
from itertools import zip_longest

names = ["Alice", "Bob", "Charlie"]
scores = [85, 92]

# fillvalue 可以設定任何你想要的值 (預設是 None)
for i, (name, score) in enumerate(zip_longest(names, scores, fillvalue="缺考")):
    print(f"第 {i+1} 位: {name} - {score}")
```

輸出結果

```plaintext
第 1 位: Alice - 85
第 2 位: Bob - 92
第 3 位: Charlie - 缺考  <-- 成功保留，並填入預設值
```

| 特性            | 標準 zip()         |      itertools.zip_longest()       |
| :-------------- | ------------------ | :--------------------------------: |
| 長度依據        | 最短的列表         |             最長的列表             |
| 多餘資料        | 丟棄 (截斷)        |                保留                |
| 缺失填充        | 無                 |     使用 fillvalue (預設 None)     |
| 使用時機        | 確定資料一一對應時 | 資料長度可能不一致，且不能掉資料時 |
| 需不需要 import | 不需要 (內建)      |  需要 (from itertools import ...)  |

(6). 補充技巧:結合字典 (Dictionary)

不管是 zip 還是 zip_longest，它們產生的成對資料，是建立字典最快的方法。

```python
keys = ["name", "age", "city"]
values = ["Alice", 25]  # 缺少 city

# 直接轉成字典
# 這裡 values 少一個，所以 city 會對應到 fillvalue (Unknown)
data_dict = dict(zip_longest(keys, values, fillvalue="Unknown"))

print(data_dict)

```
