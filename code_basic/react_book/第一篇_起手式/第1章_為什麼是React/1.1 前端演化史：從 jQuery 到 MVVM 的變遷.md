# 1.1 前端演化史：從 jQuery 到 MVVM 的變遷

## 前端開發的時代演進

### jQuery 時代（2006-2015）

#### jQuery 的興起
- **誕生背景**：解決跨瀏覽器相容性問題
- **核心優勢**：
  - 簡化 DOM 操作
  - 統一的 API
  - 豐富的插件生態
  - 優秀的文件與社群

#### jQuery 的黃金時期
```javascript
// jQuery 典型程式碼
$(document).ready(function() {
  $('#submit-btn').click(function() {
    var name = $('#name-input').val();
    $('#greeting').text('Hello, ' + name);
  });
});
```

**優點**：
- ✅ 學習曲線平緩
- ✅ 跨瀏覽器相容性極佳
- ✅ 豐富的插件生態系

**缺點**：
- ❌ 大量的 DOM 操作容易造成效能問題
- ❌ 程式碼難以維護（義大利麵式程式碼）
- ❌ 缺乏結構化的程式組織方式

### MVVM 架構的崛起（2010-2016）

#### 什麼是 MVVM？
**MVVM = Model-View-ViewModel**

- **Model**：資料層，負責業務邏輯與資料
- **View**：視圖層，負責 UI 呈現
- **ViewModel**：視圖模型層，連接 View 和 Model

#### MVVM 的代表框架

**1. Knockout.js（2010）**
```javascript
// Knockout.js 範例
function ViewModel() {
  this.name = ko.observable('World');
  this.greeting = ko.computed(function() {
    return 'Hello, ' + this.name();
  }, this);
}

ko.applyBindings(new ViewModel());
```

**2. AngularJS（2010）**
```javascript
// AngularJS 範例
angular.module('app', [])
  .controller('MainCtrl', function($scope) {
    $scope.name = 'World';
    $scope.greeting = function() {
      return 'Hello, ' + $scope.name;
    };
  });
```

**3. Vue.js（2014）**
```javascript
// Vue.js 範例
new Vue({
  el: '#app',
  data: {
    name: 'World'
  },
  computed: {
    greeting() {
      return 'Hello, ' + this.name;
    }
  }
});
```

### 從 jQuery 到 MVVM 的典範轉移

#### jQuery 思維（指令式）
```javascript
// 指令式：告訴電腦「怎麼做」
$('#add-item').click(function() {
  var item = $('#item-input').val();
  var $li = $('<li>').text(item);
  $('#item-list').append($li);
  $('#item-input').val('');
});
```

#### MVVM 思維（宣告式）
```javascript
// 宣告式：告訴電腦「做什麼」
{
  data: {
    items: [],
    newItem: ''
  },
  methods: {
    addItem() {
      this.items.push(this.newItem);
      this.newItem = '';
    }
  }
}
```

### MVVM 帶來的革命性改變

#### 1. 資料綁定（Data Binding）
- 雙向綁定：View ↔ ViewModel
- 自動同步：資料變更自動更新 UI

#### 2. 關注點分離（Separation of Concerns）
- 邏輯與視圖分離
- 更好的可測試性
- 更易維護的程式碼

#### 3. 元件化思維（Componentization）
- 可重用的 UI 元件
- 獨立的功能模組
- 更好的程式碼組織

### React 在這段歷史中的位置

React（2013）並不完全是 MVVM，而是引入了新的思維：

- **單向資料流**：比雙向綁定更可預測
- **Virtual DOM**：更高效的更新機制
- **元件化**：更徹底的元件思維
- **函式式程式設計**：更宣告式的 UI

## 時間軸總覽

```
2006 ─ jQuery 誕生
     │
2010 ─ Knockout.js / AngularJS 出現
     │  MVVM 架構興起
2013 ─ React 誕生
     │  引入 Virtual DOM 與單向資料流
2014 ─ Vue.js 誕生
     │  結合 MVVM 與元件化
2015 ─ React Native
     │  跨平台開發
2016 ─ Angular 2+
     │  完全重寫
2020+ ─ React Hooks 成為主流
     │  現代化 React 開發
```

## 為什麼選擇 React？

從歷史演進來看，React 的優勢：

1. **學習了前人的經驗**
   - 吸收 MVVM 的優點
   - 避免雙向綁定的複雜性

2. **創新的解決方案**
   - Virtual DOM 提升效能
   - 單向資料流更易除錯

3. **強大的生態系**
   - 龐大的社群支持
   - 豐富的第三方套件

4. **持續進化**
   - Hooks 簡化狀態管理
   - Concurrent Mode 提升效能
   - Server Components 新突破

## 思考題

1. 為什麼 jQuery 在現代前端開發中逐漸式微？
2. MVVM 的雙向綁定與 React 的單向資料流各有什麼優缺點？
3. 你認為未來的前端框架會朝什麼方向發展？

## 延伸閱讀

- [jQuery 官方網站](https://jquery.com/)
- [跨越十年的前端框架演變](https://www.smashingmagazine.com/2021/03/history-frontend-development/)
- [MVVM 架構模式詳解](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)
