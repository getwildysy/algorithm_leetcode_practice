# 1.2 React 的核心哲學：宣告式 UI (Declarative) vs. 指令式 UI (Imperative)

## 指令式 vs. 宣告式程式設計

### 生活中的例子

**指令式（Imperative）**：告訴別人「怎麼做」
> 「走到路口，右轉，走 200 公尺，看到紅色建築物，進去，上二樓」

**宣告式（Declarative）**：告訴別人「做什麼」
> 「我要去台北 101」

### 程式設計中的差異

#### 指令式：一步一步告訴電腦怎麼做

```javascript
// 指令式：陣列加總
const numbers = [1, 2, 3, 4, 5];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}
console.log(sum); // 15
```

#### 宣告式：告訴電腦你要什麼結果

```javascript
// 宣告式：陣列加總
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15
```

## UI 開發中的指令式 vs. 宣告式

### 指令式 UI（傳統 DOM 操作）

#### 範例：簡單的計數器

```javascript
// 指令式 UI - 使用原生 JavaScript
let count = 0;
const counterElement = document.getElementById('counter');
const incrementBtn = document.getElementById('increment');
const decrementBtn = document.getElementById('decrement');

// 更新顯示的函式
function updateDisplay() {
  counterElement.textContent = count;
}

// 增加按鈕
incrementBtn.addEventListener('click', function() {
  count++;
  updateDisplay();
});

// 減少按鈕
decrementBtn.addEventListener('click', function() {
  count--;
  updateDisplay();
});

updateDisplay();
```

**特點**：
- ❌ 需要手動操作 DOM
- ❌ 需要手動同步狀態與 UI
- ❌ 程式碼冗長且容易出錯
- ❌ 難以追蹤狀態變化

### 宣告式 UI（React 方式）

#### 範例：同樣的計數器

```jsx
// 宣告式 UI - 使用 React
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>計數：{count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
      <button onClick={() => setCount(count - 1)}>減少</button>
    </div>
  );
}
```

**特點**：
- ✅ 描述 UI「應該是什麼樣子」
- ✅ React 自動處理 DOM 更新
- ✅ 程式碼簡潔清晰
- ✅ 狀態變化一目了然

## React 的宣告式哲學

### 核心概念：UI = f(state)

React 的核心思想可以用一個簡單的公式表達：

```
UI = function(state)
```

**意思是**：UI 是狀態的函式，給定相同的狀態，就會產生相同的 UI。

### 範例：待辦事項列表

#### 指令式寫法

```javascript
// 指令式 - jQuery
function addTodo(text) {
  const $li = $('<li>');
  const $checkbox = $('<input type="checkbox">');
  const $span = $('<span>').text(text);
  const $deleteBtn = $('<button>').text('刪除');
  
  $checkbox.on('change', function() {
    if ($(this).is(':checked')) {
      $span.css('text-decoration', 'line-through');
    } else {
      $span.css('text-decoration', 'none');
    }
  });
  
  $deleteBtn.on('click', function() {
    $li.remove();
  });
  
  $li.append($checkbox, $span, $deleteBtn);
  $('#todo-list').append($li);
}
```

#### 宣告式寫法

```jsx
// 宣告式 - React
function TodoList() {
  const [todos, setTodos] = useState([]);

  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          />
          <span style={{ 
            textDecoration: todo.completed ? 'line-through' : 'none' 
          }}>
            {todo.text}
          </span>
          <button onClick={() => deleteTodo(todo.id)}>刪除</button>
        </li>
      ))}
    </ul>
  );
}
```

## 宣告式 UI 的優勢

### 1. 更易理解與維護

**指令式**：需要閱讀所有操作步驟才能理解結果
**宣告式**：直接看到最終狀態

### 2. 更少的 Bug

```javascript
// 指令式：容易忘記更新某個地方
function updateUser(id, name) {
  // 更新列表中的名字
  $('#user-' + id + ' .name').text(name);
  // 更新標題中的名字
  $('#header .user-name').text(name);
  // 糟糕！忘記更新側邊欄的名字了！
  // $('#sidebar .user-name').text(name);
}

// 宣告式：狀態改變，所有地方自動更新
function updateUser(id, name) {
  setUser({ ...user, name }); // 所有使用 user.name 的地方都會自動更新
}
```

### 3. 更容易推理

```jsx
// 宣告式：條件渲染一目了然
function Greeting({ isLoggedIn, user }) {
  return (
    <div>
      {isLoggedIn ? (
        <h1>歡迎回來，{user.name}！</h1>
      ) : (
        <h1>請先登入</h1>
      )}
    </div>
  );
}
```

### 4. 更好的可組合性

```jsx
// 元件可以輕鬆組合
function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <Main />
      <Footer />
    </div>
  );
}
```

## 實際對比案例

### 案例：動態表單驗證

#### 指令式

```javascript
// 需要手動管理每個輸入欄位的狀態
const emailInput = document.getElementById('email');
const emailError = document.getElementById('email-error');

emailInput.addEventListener('input', function() {
  const value = this.value;
  if (!value.includes('@')) {
    emailError.style.display = 'block';
    emailError.textContent = '請輸入有效的 email';
    this.classList.add('error');
  } else {
    emailError.style.display = 'none';
    this.classList.remove('error');
  }
});
```

#### 宣告式

```jsx
function EmailInput() {
  const [email, setEmail] = useState('');
  const isValid = email.includes('@');

  return (
    <div>
      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        className={!isValid ? 'error' : ''}
      />
      {!isValid && <span className="error">請輸入有效的 email</span>}
    </div>
  );
}
```

## React 如何實現宣告式 UI？

### 虛擬 DOM（Virtual DOM）

React 在背後維護一個虛擬的 DOM 樹，開發者只需要描述 UI 應該是什麼樣子，React 會：

1. 計算新舊虛擬 DOM 的差異
2. 只更新真正需要改變的部分
3. 批次處理更新以提升效能

```jsx
// 你寫的是宣告式的程式碼
<div className={isActive ? 'active' : 'inactive'}>
  {message}
</div>

// React 在背後做了所有複雜的 DOM 操作
```

## 最佳實踐

### ✅ Do：思考「狀態」而非「操作」

```jsx
// Good：描述狀態
const [isOpen, setIsOpen] = useState(false);

return (
  <Modal isOpen={isOpen}>
    {/* ... */}
  </Modal>
);
```

### ❌ Don't：在 React 中進行指令式操作

```jsx
// Bad：直接操作 DOM
function MyComponent() {
  const handleClick = () => {
    document.getElementById('my-div').style.display = 'none';
  };
  // ...
}
```

## 思考題

1. 為什麼宣告式 UI 比指令式 UI 更容易維護？
2. 在什麼情況下可能還是需要使用指令式的方式？
3. React 的宣告式哲學如何影響程式碼的組織方式？

## 小結

React 的宣告式哲學讓開發者專注於「**應該顯示什麼**」，而不是「**如何顯示**」。這種思維轉變是學習 React 最重要的第一步。

記住：**UI = f(state)**，這是 React 的核心！
