# 1.3 Virtual DOM 的秘密：為什麼它比較快？(Reconciliation 簡介)

## DOM 操作為什麼慢？

### 真實 DOM 的成本

```javascript
// 看似簡單的操作
document.getElementById('app').innerHTML = '<h1>Hello</h1>';

// 實際上瀏覽器做了：
// 1. 解析 HTML 字串
// 2. 建立 DOM 節點
// 3. 觸發樣式重新計算
// 4. 觸發頁面重排 (Reflow)
// 5. 觸發頁面重繪 (Repaint)
```

**真實 DOM 操作的代價**：
- 🐌 每次操作都可能觸發重排與重繪
- 🐌 DOM API 呼叫本身就有效能開銷
- 🐌 頻繁的小更新會導致效能問題

### 傳統方式的問題

```javascript
// 更新 100 個列表項
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  li.textContent = `項目 ${i}`;
  ul.appendChild(li); // 每次都觸發重排！
}
```

## Virtual DOM 是什麼？

### 概念

**Virtual DOM** 是真實 DOM 的輕量級 JavaScript 物件表示。

```javascript
// 真實 DOM
<div className="container">
  <h1>Hello</h1>
  <p>World</p>
</div>

// Virtual DOM（簡化表示）
{
  type: 'div',
  props: { className: 'container' },
  children: [
    { type: 'h1', props: {}, children: ['Hello'] },
    { type: 'p', props: {}, children: ['World'] }
  ]
}
```

### React 元素就是 Virtual DOM

```jsx
// JSX
const element = <h1 className="greeting">Hello, world!</h1>;

// 編譯後（React 17 之前）
const element = React.createElement(
  'h1',
  { className: 'greeting' },
  'Hello, world!'
);

// 實際產生的 Virtual DOM 物件
{
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
}
```

## Virtual DOM 的運作流程

### 完整流程

```
1. 狀態改變
   ↓
2. 產生新的 Virtual DOM 樹
   ↓
3. 與舊的 Virtual DOM 樹比較（Diffing）
   ↓
4. 計算出最小的變更集
   ↓
5. 批次更新真實 DOM
```

### 視覺化範例

```jsx
// 初始狀態
<ul>
  <li>Apple</li>
  <li>Banana</li>
</ul>

// 狀態更新後
<ul>
  <li>Apple</li>
  <li>Banana</li>
  <li>Cherry</li>  // 新增
</ul>

// React 的處理：
// ✅ 只新增一個 <li> 節點
// ✅ 不會重新渲染整個列表
```

## Reconciliation（協調）演算法

### 什麼是 Reconciliation？

Reconciliation 是 React 用來比較新舊 Virtual DOM 並決定如何更新真實 DOM 的演算法。

### Diffing 演算法的策略

#### 策略 1：不同類型的元素會產生不同的樹

```jsx
// 舊的
<div>
  <Counter />
</div>

// 新的
<span>
  <Counter />
</span>

// React 的處理：
// - 完全移除舊的 div 及其子元素
// - 建立新的 span 及其子元素
// - Counter 元件會被完全重新掛載
```

#### 策略 2：同類型的 DOM 元素，只更新改變的屬性

```jsx
// 舊的
<div className="before" title="stuff" />

// 新的
<div className="after" title="stuff" />

// React 的處理：
// - 只更新 className 屬性
// - title 保持不變
```

#### 策略 3：同類型的元件，保持實體並更新 props

```jsx
// 舊的
<MyComponent name="Alice" />

// 新的
<MyComponent name="Bob" />

// React 的處理：
// - 保持 MyComponent 的實體
// - 只更新 name prop
// - 元件會收到新的 props 並重新渲染
```

### Key 的重要性

#### 沒有 key 的問題

```jsx
// 初始列表
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

// 在開頭插入新項目
<ul>
  <li>Connecticut</li>  // 新增
  <li>Duke</li>
  <li>Villanova</li>
</ul>

// 沒有 key 時：
// React 會認為：
// - 第一個 <li> 從 "Duke" 變成 "Connecticut" → 更新
// - 第二個 <li> 從 "Villanova" 變成 "Duke" → 更新
// - 新增第三個 <li> "Villanova" → 插入
// 結果：更新了 3 個節點！
```

#### 使用 key 的優化

```jsx
<ul>
  <li key="duke">Duke</li>
  <li key="villanova">Villanova</li>
</ul>

// 在開頭插入
<ul>
  <li key="connecticut">Connecticut</li>
  <li key="duke">Duke</li>
  <li key="villanova">Villanova</li>
</ul>

// 有 key 時：
// React 知道：
// - key="duke" 和 key="villanova" 的元素沒變
// - 只需要插入一個新的 key="connecticut"
// 結果：只操作了 1 個節點！
```

## 為什麼 Virtual DOM 比較快？

### 原因 1：減少 DOM 操作

```javascript
// 傳統方式：10 次 DOM 操作
for (let i = 0; i < 10; i++) {
  element.style.color = colors[i]; // 每次都觸發重繪
}

// Virtual DOM 方式：1 次 DOM 操作
// React 會批次處理，最後只設定一次
```

### 原因 2：批次更新

```jsx
function handleClick() {
  setCount(count + 1);  // 不會立即更新 DOM
  setName('Alice');     // 不會立即更新 DOM
  setEmail('alice@example.com'); // 不會立即更新 DOM
  
  // React 會批次處理這些狀態更新
  // 只執行一次渲染和 DOM 更新
}
```

### 原因 3：精確的更新

```jsx
// 只有 count 改變了
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>不變的標題</h1>
      <p>計數：{count}</p>  {/* 只更新這裡 */}
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}

// React 只會更新 <p> 標籤的文字內容
// 其他部分完全不動
```

## 實際效能對比

### 範例：更新大列表

#### 原生 JavaScript（指令式）

```javascript
// 更新 1000 個項目
function updateList(items) {
  const ul = document.getElementById('list');
  ul.innerHTML = ''; // 清空
  
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    ul.appendChild(li); // 1000 次 DOM 操作
  });
}
```

#### React（宣告式 + Virtual DOM）

```jsx
function List({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

// React 會：
// 1. 比較新舊列表
// 2. 只更新改變的項目
// 3. 批次處理 DOM 更新
```

## Virtual DOM 的限制

### 不是萬能的

```jsx
// Virtual DOM 也有成本
// 1. 建立 Virtual DOM 樹需要記憶體
// 2. Diffing 演算法需要計算時間
// 3. 對於非常簡單的更新，可能不如直接操作 DOM
```

### 何時 Virtual DOM 的優勢最明顯？

✅ **適合的場景**：
- 複雜的 UI 更新
- 頻繁的狀態變化
- 大量的元件互動

❌ **可能不適合的場景**：
- 極簡單的靜態頁面
- 需要極致效能的動畫（可考慮 Canvas 或 WebGL）

## React 18 的改進：Concurrent Rendering

### 傳統渲染

```
渲染開始 → 執行完畢 → DOM 更新
（期間無法中斷，可能造成卡頓）
```

### Concurrent Rendering

```
渲染開始 → 可以暫停 ← 處理更高優先級的任務
    ↓
繼續渲染 → 完成 → DOM 更新
```

## 實戰技巧

### 優化技巧 1：使用正確的 key

```jsx
// ❌ 不要用 index 當 key（如果列表會重新排序）
{items.map((item, index) => (
  <li key={index}>{item}</li>
))}

// ✅ 使用穩定的唯一識別碼
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}
```

### 優化技巧 2：避免不必要的渲染

```jsx
// ✅ 使用 React.memo 避免不必要的重新渲染
const MyComponent = React.memo(function MyComponent({ name }) {
  return <div>{name}</div>;
});
```

### 優化技巧 3：列表渲染優化

```jsx
// ✅ 使用虛擬列表（對於超大列表）
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={500}
  itemCount={1000}
  itemSize={35}
>
  {Row}
</FixedSizeList>
```

## 思考題

1. Virtual DOM 在每種情況下都比直接操作 DOM 快嗎？
2. 為什麼用 index 當 key 可能會導致問題？
3. React 的批次更新機制如何提升效能？

## 小結

Virtual DOM 的核心價值：
- ✅ 提供宣告式的開發體驗
- ✅ 自動優化 DOM 更新
- ✅ 減少不必要的渲染
- ✅ 跨平台的抽象層（React Native）

記住：**Virtual DOM 不只是效能優化，更重要的是提供了更好的開發體驗！**
