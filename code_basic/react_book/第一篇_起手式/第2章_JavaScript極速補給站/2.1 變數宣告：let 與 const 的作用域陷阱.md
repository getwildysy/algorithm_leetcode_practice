# 2.1 變數宣告：let 與 const 的作用域陷阱

在 JavaScript 中，變數宣告是所有程式的基礎。ES6 (ES2015) 引入了 `let` 與 `const`，徹底改變了我們管理變數的方式。這不只是語法的改變，更是對「作用域 (Scope)」控制權的提升。

## 1. 作用域 (Scope) 的演進

### 1.1 什麼是作用域？
簡單來說，作用域就是**變數存活的範圍**。超出這個範圍，變數就「死掉」了（無法被存取）。

### 1.2 函式作用域 (Function Scope) - `var` 的舊時代
在 ES6 之前，只有 Function 能創造新的作用域。

```javascript
// ❌ 區塊 (如 if, for) 擋不住 var
if (true) {
  var x = 100;
}
console.log(x); // 100 (變數洩漏出來了！)
```
這導致了變數常常意外地污染全域，或是被後面的程式碼意外覆蓋。

### 1.3 區塊作用域 (Block Scope) - `let` / `const` 的新時代
`let` 和 `const` 認得大括號 `{ }`。任何一對大括號（if, for, while, 或是單純的 block）都會創造一個新的封閉世界。

```javascript
// ✅ 區塊擋得住 let
if (true) {
  let y = 100;
}
console.log(y); // ReferenceError: y is not defined (安全！)
```

---

## 2. 提升 (Hoisting) 的真相

你可能聽過「變數提升」，但它在 `let` / `const` 中的行為與 `var` 完全不同。

### 2.1 `var` 的提升
`var` 會被「拉」到函式最頂端，並初始化為 `undefined`。

```javascript
console.log(a); // undefined (不會報錯，但值是空的)
var a = 5;
```

### 2.2 暫時性死區 (Temporal Dead Zone, TDZ)
`let` 和 `const` 也會被提升（JS 引擎知道它們存在），但在程式執行到宣告那一行之前，它們處於 **TDZ** 狀態。

```javascript
// [TDZ Start] -------------------------
// 
console.log(b); // ❌ ReferenceError: Cannot access 'b' before initialization
// 即使你知道下面有 b，現在也不能摸它！
//
// [TDZ End] ---------------------------
let b = 10; 
console.log(b); // ✅ 10
```

> [!IMPORTANT]
> **React 開發原則**：其實你不需要背誦 hoisting 的規則。只要養成 **「永遠在使用變數之前宣告它」** 的好習慣，這些問題自然消失。

---

## 3. `let` vs `const`: 該選哪一個？

### 迷思：「變數」不是應該要能「變」嗎？
很多人習慣因為「它是變數」就用 `let`。但在現代開發（尤其是 React）中，思維是反過來的。

### 黃金法則 (Golden Rule)
1. **預設全部使用 `const`**。
2. 只有當你**確定**這個變數稍後會被重新賦值 (`=`) 時，才改成 `let`。
3. **永遠不要使用 `var`**。

### 為什麼 React 偏愛 `const`？
React 強調 **Immutability (不可變性)**。使用 `const` 可以保護變數引用不被意外修改。

```javascript
// ❌ 壞習慣：用 let 但從不修改
let user = { name: 'Alice' }; 
// ... 500 lines later ...
// 你不確定 user 有沒有被偷換成別的物件

// ✅ 好習慣：用 const
const user = { name: 'Alice' };
// 你很確定 user 永遠指向這個物件
```

> [!NOTE]
> `const` 鎖定的是 **「變數的指向 (Reference)」**，而不是 **「物件的內容 (Value)」**。
> ```javascript
> const arr = [];
> arr.push(1); // ✅ 合法！因為 arr 還是指向同一個陣列記憶體位置。
> arr = [1];   // ❌ 錯誤！試圖讓 arr 指向新的陣列。
> ```

---

## 4. 迴圈中的陷阱：Closure (閉包) 與 Scope

這是一個經典的面試題，也是非同步處理常遇到的坑。

### 場景：每秒印出一個數字

#### ❌ 使用 `var` (共用變數)
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); 
  }, 100);
}
// 結果：3, 3, 3
```
**原因**：只有一個全域的 `i`。當 `setTimeout` 執行時，迴圈早就跑完了，`i` 已經停在 3。三個 callback 都看著同一個 `i`。

#### ✅ 使用 `let` (獨立變數)
```javascript
for (let i = 0; i < 3; i++) {
  // 每次迴圈，都會產生一個「全新的 i」
  setTimeout(() => {
    console.log(i); 
  }, 100);
}
// 結果：0, 1, 2
```
**原因**：`let` 具有區塊作用域。每次迴圈產生的 block 都有自己獨立的 `i` (Snapshot)。

---

## 5. 總結

| 特性 | var | let | const |
| :--- | :--- | :--- | :--- |
| **作用域** | Function Scope | Block Scope | Block Scope |
| **提升 (Hoisting)** | 初始化為 undefined | 進入 TDZ (報錯) | 進入 TDZ (報錯) |
| **重複宣告** | 允許 (危險) | 禁止 | 禁止 |
| **重新賦值** | 允許 | 允許 | 禁止 |
| **使用建議** | **禁用 💀** | **只在迴圈或計數器用** | **預設首選 👑** |
