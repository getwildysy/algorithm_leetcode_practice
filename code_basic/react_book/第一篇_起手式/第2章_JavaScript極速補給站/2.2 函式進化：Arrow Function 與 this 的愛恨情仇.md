# 2.2 函式進化：Arrow Function 與 this 的愛恨情仇

Arrow Function (`=>`) 不僅僅是縮寫，它解決了 JavaScript 長期以來最令人頭痛的 `this` 指向問題。

## 1. 語法進化論

### 1.1 從長到短

```javascript
// 傳統函式
const add = function(a, b) {
  return a + b;
};

// 進化 1：去掉 function 關鍵字
const add = (a, b) => {
  return a + b;
};

// 進化 2：隱式回傳 (Implicit Return)
// 當函式主體只有一行表達式時，可以拿掉 { } 和 return
const add = (a, b) => a + b;
```

### 1.2 隱式回傳的陷阱 (回傳物件)

在 React 中，我們常需要直接回傳一個物件（例如 `mapStateToProps` 或 `useReducer`）。

```javascript
// ❌ 錯誤：JS 引擎以為 { } 是程式區塊 (Block)
const getUser = (name) => { name: name, id: 1 }; 
// 結果：undefined

// ✅ 正確：用小括號 ( ) 包起來，強制視為表達式
const getUser = (name) => ({ name: name, id: 1 });
```

---

## 2. `this` 的愛恨情仇

### 2.1 傳統函式的 `this` (Call Site)
傳統函式的 `this` 是**動態的**，取決於 **「誰呼叫了它」**。

```javascript
const user = {
  name: 'Alice',
  sayHi: function() {
    console.log('Hi, ' + this.name);
  }
};

user.sayHi(); // 'Hi, Alice' (user 呼叫的)

const fn = user.sayHi;
fn(); // 'Hi, undefined' (全域呼叫的，this 變成了 window 或 undefined)
```
這在 React Class Component 時代是個大災難，我們必須到處寫 `.bind(this)`。

### 2.2 箭頭函式的 `this` (Lexical Scope)
箭頭函式**沒有自己的 `this`**。它會像查找變數一樣，往外層找 `this`。這稱為 **Lexical Scoping (詞法作用域)** —— 寫程式碼的位置決定了 `this`，而不是呼叫的方式。

```javascript
const user = {
  name: 'Alice',
  sayHi: () => {
    // 這裡的 this 往外找 -> Global Object
    console.log('Hi, ' + this.name);
  }
};

user.sayHi(); // 'Hi, undefined' 
```

> [!WARNING]
> **不要在物件方法中使用箭頭函式**（如上例），除非你很確定需要外層的 `this`。

---

## 3. React 中的應用模式

### 3.1 簡潔的 Component

```jsx
// 以前
function Card(props) {
  return <div>{props.title}</div>;
}

// 現在 (箭頭函式 + 解構 + 隱式回傳)
const Card = ({ title }) => (
  <div>{title}</div>
);
```

### 3.2 Currying (柯里化) 與事件處理

在處理列表的事件時，這是一個非常強大的模式。

**需求**：有一個輸入框列表，變更時更新對應的資料。

**傳統寫法 (Inline Arrow)**：
```jsx
{items.map(item => (
  <input 
    key={item.id}
    onChange={(e) => handleChange(item.id, e)} // 每次 render 都產生新函式
  />
))}
```

**Currying 寫法 (Higher Order Function)**：
```javascript
// 一個接收 ID 的函式，回傳一個接收 Event 的函式
const handleChange = (id) => (e) => {
  console.log('Updating', id, e.target.value);
};

// 使用時更乾淨
<input onChange={handleChange(item.id)} />
```

## 4. 總結：何時該用誰？

| 場景 | 推薦語法 | 原因 |
| :--- | :--- | :--- |
| **React Component** | Arrow Function | 簡潔、易於 TypeScript 型別定義 |
| **Array Methods (map, filter)** | Arrow Function | 隱式回傳讓程式碼像數學公式一樣美 |
| **Object Methods** | Traditional Function | 需要存取物件本身的 `this` |
| **Event Handlers** | Arrow Function | 不需要擔心 `this` 跑掉 (Class Component 中) |

**一句話總結**：除了定義物件的方法 (Object Methods) 之外，現代 React 開發幾乎**全用 Arrow Function**。
