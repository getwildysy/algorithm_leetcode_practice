# 2.3 資料處理神器：Destructuring (解構賦值) 與 Spread Operator (...)

在現代 React 開發中，解構賦值 (Destructuring) 與展開運算子 (Spread Operator, `...`) 是最頻繁使用的語法。它們能讓你的程式碼更簡潔、更具可讀性，是處理 Props 與 State 的必備技能。

## 1. 解構賦值 (Destructuring Assignment)

解構賦值允許我們從陣列或物件中提取資料，並將其賦值給新的變數。

### 1.1 物件解構 (Object Destructuring)

這是 React 中最常見的模式，特別是用於 `props`。

**傳統寫法 vs 解構寫法：**

```javascript
const user = {
  name: 'Alice',
  age: 25,
  location: 'Taipei'
};

// ❌ 傳統寫法：重複引用 user
const name = user.name;
const age = user.age;

// ✅ 解構寫法：一次提取
const { name, age } = user;
```

**進階技巧：**

1.  **重新命名變數**：
    ```javascript
    const { name: userName, age: userAge } = user;
    console.log(userName); // 'Alice'
    ```

2.  **設定預設值**：
    當屬性不存在 (undefined) 時，使用預設值。
    ```javascript
    const { role = 'Guest' } = user;
    console.log(role); // 'Guest' (因為 user 物件中沒有 role)
    ```

3.  **巢狀解構**：
    ```javascript
    const profile = {
      id: 1,
      details: {
        email: 'alice@example.com',
        phone: '0912345678'
      }
    };
    
    // 直接提取深層屬性
    const { details: { email } } = profile;
    ```

### 1.2 陣列解構 (Array Destructuring)

React Hooks 的 `useState` 就是陣列解構的最佳範例。

```javascript
// ✅ useState 返回一個陣列 [currentValue, setValueFunction]
const [count, setCount] = useState(0);

// 自定義變數名稱
const [user, setUser] = useState(null);
```

1.  **跳過元素**：
    ```javascript
    const numbers = [1, 2, 3];
    const [first, , third] = numbers; // 跳過 second
    console.log(third); // 3
    ```

---

## 2. 展開運算子 (Spread Operator) `...`

展開運算子可以將「陣列」或「物件」展開成獨立的元素。

### 2.1 物件展開 (Object Spread)

在 React 中，這常用於**更新 State** (因為 React State 是不可變的，我們必須建立新物件)。

**場景：更新使用者資料的一部分**

```javascript
const user = { id: 1, name: 'Alice', role: 'User' };

// ❌ 錯誤：直接修改 (Mutation) - React 不會偵測到變更
user.role = 'Admin'; 

// ✅ 正確：建立新物件 (Immutable Update)
const updatedUser = {
  ...user,          // 1. 複製舊 user 的所有屬性
  role: 'Admin'     // 2. 覆蓋 role 屬性
};
// updatedUser: { id: 1, name: 'Alice', role: 'Admin' }
```

> [!IMPORTANT]
> 順序很重要！後面的屬性會覆蓋前面的。如果寫成 `{ role: 'Admin', ...user }`，那麼 `user.role` ('User') 會覆蓋 'Admin'。

### 2.2 陣列展開 (Array Spread)

用於合併陣列或添加新元素。

```javascript
const fruits = ['Apple', 'Banana'];

// 添加新元素 (Immutable push)
const newFruits = [...fruits, 'Cherry']; 
// ['Apple', 'Banana', 'Cherry']

// 合併陣列
const moreFruits = ['Date', 'Elderberry'];
const allFruits = [...fruits, ...moreFruits];
```

### 2.3 剩餘參數 (Rest Parameters)

雖然符號也是 `...`，但在函式參數定義或解構賦值中，它叫「Rest」，用來收集「剩下的」東西。

```javascript
// 從物件中剔除特定屬性
const fullProfile = { id: 1, name: 'Alice', secret: '123456' };

// 取出 secret，剩下的都放入 publicInfo
const { secret, ...publicInfo } = fullProfile;

console.log(publicInfo); // { id: 1, name: 'Alice' }
```

---

## 3. React 實戰應用

### 3.1 Props 解構與傳遞

這是你在 React Component 中最常看到的寫法。

```jsx
// 1. 在參數中直接解構 Props
function UserCard({ name, age, avatar = 'default.png' }) {
  return (
    <div className="card">
      <img src={avatar} alt={name} />
      <h2>{name}</h2>
      <p>Age: {age}</p>
    </div>
  );
}

// 2. 使用 Spread 透傳 Props (Props Drilling)
function Layout(props) {
  // 將所有接收到的 props 傳遞給子元件
  return <div className="layout" {...props} />;
}
```

### 3.2 複雜 State 更新

當 State 是一個複雜物件時：

```jsx
const [form, setForm] = useState({
  username: '',
  password: '',
  email: ''
});

const handleEmailChange = (e) => {
  setForm({
    ...form,                // 保留 username 和 password
    email: e.target.value   // 只更新 email
  });
};
```

## 小結

- **解構賦值**：讓提取資料更優雅，是 Component Props 的標準寫法。
- **展開運算子**：是操作 Immutable Data (不可變資料) 的神器，無論是複製物件還是更新陣列，都離不開它。
