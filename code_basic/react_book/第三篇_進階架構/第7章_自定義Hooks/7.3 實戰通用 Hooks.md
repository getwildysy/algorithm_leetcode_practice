# 7.3 實戰通用 Hooks

學會了理論，我們來看看業界最常用的幾個 Custom Hooks。

## 1. useWindowSize：RWD 利器

雖然 CSS Media Query 很好用，但有時候我們需要用 JS 邏輯來決定渲染什麼元件（例如：手機版顯示漢堡選單，桌機版顯示完整導航）。

```jsx
import { useState, useEffect } from "react";

export function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: undefined,
    height: undefined,
  });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener("resize", handleResize);
    handleResize(); // 初始執行一次

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return windowSize;
}
```

## 2. useDebounce：防止頻繁請求

當使用者在搜尋框打字時，我們不希望每打一個字就發一次 API 請求。這種技術叫做 Debounce (防抖)。

```jsx
import { useState, useEffect } from "react";

export function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // 設定一個計時器，在 delay 毫秒後更新值
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // 如果在 delay 內 value 又變了，useEffect 會重新執行
    // 這裡的 cleanup 會把上一次的計時器清除！
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

### 如何使用？

```jsx
function SearchBox() {
  const [text, setText] = useState('');
  const debouncedText = useDebounce(text, 500); // 延遲 500ms

  useEffect(() => {
    // 只有當 debouncedText 改變時才會執行 API
    if (debouncedText) {
      searchAPI(debouncedText);
    }
  }, [debouncedText]);

  return <input value={text} onChange={e => setText(e.target.value)} />;
}
```

## 3. useLocalStorage：持久化狀態

就像 `useState`，但是會自動同步到瀏覽器的 localStorage。

```jsx
import { useState } from "react";

export function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.log(error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      // 支援 functional update
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue];
}
```

## 小結

Custom Hooks 的威力在於它們是「可組合」的。你可以把 `useWindowSize` 和 `useDebounce` 組合在一起，創造更強大的邏輯。
