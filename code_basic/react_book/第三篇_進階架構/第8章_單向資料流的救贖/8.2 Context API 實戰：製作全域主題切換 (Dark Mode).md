# 8.2 Context API 實戰：製作全域主題切換 (Dark Mode)

## 本節大綱

### Context API 基礎
- createContext
- Provider
- useContext
- Context的運作原理

### 建立 Theme Context
- 設計 Context 結構
- Provider 元件
- Context 的值
- 預設值設定

### 主題切換實作
- Dark/Light 模式
- 主題狀態管理
- CSS 變數整合
- 持久化（localStorage）

### Context 的最佳實踐
- 拆分 Context
- Provider 組合
- 效能優化
- 避免不必要的渲染

## 學習目標

- [ ] 熟練使用 Context API
- [ ] 實作完整的主題系統
- [ ] 掌握 Context 最佳實踐
- [ ] 理解效能優化技巧



Context 提供了一種「傳送門」機制，讓資料可以直接跳過中間層級，傳遞給需要的子元件。

## 1. Context 三部曲

使用 Context 只需要三個步驟：**Create**, **Provide**, **Consume**。

### Step 1: Create Context
```jsx
// ThemeContext.js
import { createContext } from 'react';

// 建立一個 Context 物件，可以給預設值 (但在有 Provider 時預設值會被蓋過)
export const ThemeContext = createContext('light');
```

### Step 2: Provide (提供者)
在最外層 (或某個父層) 包上 `Provider`。

```jsx
// App.jsx
import { useState } from 'react';
import { ThemeContext } from './ThemeContext';

function App() {
  const [theme, setTheme] = useState('light');

  return (
    // value 屬性就是你想傳送的資料
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Layout />
    </ThemeContext.Provider>
  );
}
```

### Step 3: Consume (消費者)
在任何子元件中，使用 `useContext` 勾子來拿資料。

```jsx
// ThemeButton.jsx
import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function ThemeButton() {
  const { theme, setTheme } = useContext(ThemeContext); // 直接拿到 value

  return (
    <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>
      Current: {theme}
    </button>
  );
}
```

---

## 2. 最佳實踐：封裝 Context Provider

為了讓程式碼更乾淨，我們通常會把 Context 和 Provider 封裝在一個檔案裡，並提供一個 Custom Hook。

```jsx
// contexts/ThemeContext.jsx
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState(() => {
    return localStorage.getItem('theme') || 'light';
  });

  useEffect(() => {
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom Hook 讓外部更好用
export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider!');
  }
  return context;
}
```

**用法變超簡單：**

```jsx
// App.jsx
<ThemeProvider>
  <Layout />
</ThemeProvider>

// Child.jsx
const { theme, toggleTheme } = useTheme();
```

## 小結

- Context 適合：Theme, User Auth, Locale (語系)。
- 缺點：Provider 下的所有 Consumers，只要 Provider 的 value 變了，**全部都會 Re-render**。
- 因此，不適合用來存「高頻率變動」的資料 (例如滑鼠座標、動畫數值)。
