# 9.1 Fetch vs. Axios：新舊世代的對決

## 本節大綱
- Fetch API 簡介
- Axios 簡介
- 兩者的差異比較
- 如何選擇？

## 學習目標
- [ ] 理解 Fetch 與 Axios 的差異
- [ ] 掌握兩者的基本用法
- [ ] 選擇適合的 HTTP 客戶端


在 React 中串接 API 時，最常見的兩個選擇是瀏覽器內建的 **Fetch API** 和老牌函式庫 **Axios**。

## 1. Fetch API：瀏覽器原生支援

Fetch 是現代瀏覽器內建的標準，不需要安裝任何套件。

```js
fetch('https://api.example.com/data')
  .then(response => {
    // ⚠️ 陷阱：404 或 500 不會進 catch！
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json(); // ⚠️ 需要多一步轉 JSON
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

### 優點
- **零依賴**：不用 `npm install`。
- **標準**：符合 Web 標準。

### 缺點
- **錯誤處理麻煩**：需手動檢查 `response.ok`。
- **兩步驟轉換**：需手動呼叫 `.json()`。
- **缺少進階功能**：沒有攔截器 (Interceptors)、Timeout 設定麻煩。

---

## 2. Axios：開發者體驗優先

Axios 是一個基於 Promise 的 HTTP 客戶端，為開發者做了很多貼心封裝。
`npm install axios`

```js
import axios from 'axios';

axios.get('https://api.example.com/data')
  .then(response => {
    // ✅ 自動轉 JSON，直接拿 data
    console.log(response.data);
  })
  .catch(error => {
    // ✅ 自動 catch 4xx/5xx 錯誤
    console.error('Error:', error.message);
  });
```

### 殺手級功能：Interceptors (攔截器)
這是 Fetch 做不到的。我們可以統一處理 Request (例如加 Token) 和 Response (例如統一跳錯誤訊息)。

```js
// 設定全域攔截器
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer ${getToken()}`;
  return config;
});

axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response.status === 401) {
      logout(); // Token 過期自動登出
    }
    return Promise.reject(error);
  }
);
```

## 小結

- 小專案、簡單 GET 請求 -> **Fetch**
- 中大型專案、需要統一管理 Auth Header、錯誤處理 -> **Axios**
