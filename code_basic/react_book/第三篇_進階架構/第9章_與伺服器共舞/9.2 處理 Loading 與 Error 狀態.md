# 9.2 處理 Loading 與 Error 狀態

串接 API 不只是「把資料拿回來」這麼簡單。良好的使用者體驗需要照顧到 **Loading (載入中)**、**Error (錯誤)** 和 **Empty (空資料)** 三種狀態。

## 1. 標準三態模式

不管是 Fetch 還是 Axios，我們通常需要三個 State 來管理一次請求。

```jsx
const [data, setData] = useState(null);
const [loading, setLoading] = useState(false); // 初始值視需求而定
const [error, setError] = useState(null);

const fetchData = async () => {
  setLoading(true);  // 1. 開始轉圈圈
  setError(null);    // 2. 清除舊錯誤
  
  try {
    const result = await api.getData();
    setData(result); // 3. 成功存資料
  } catch (err) {
    setError(err.message); // 4. 失敗存錯誤
  } finally {
    setLoading(false); // 5. 無論如何停止轉圈圈
  }
};
```

---

## 2. Race Condition (競態條件)

這是一個進階但常見的 Bug。
假設使用者快速切換分頁：`Tab A` -> `Tab B`。
1. React 發出 `Request A`。
2. React 發出 `Request B`。
3. `Request B` 先回來了 (因為 B 資料少)，畫面顯示 B。
4. `Request A` 終於回來了，**畫面被蓋成 A！** (但使用者現在停在 Tab B)。

這就是 Race Condition。

### 解法：Cleanup Function

在 `useEffect` 中利用 Cleanup 機制來忽略舊的請求。

```jsx
useEffect(() => {
  let ignore = false; // 標記 flag

  const fetchData = async () => {
    setLoading(true);
    const result = await api.getData(id);
    
    // 只有當 ignore 為 false 時才更新狀態
    if (!ignore) {
      setData(result);
      setLoading(false);
    }
  };

  fetchData();

  return () => {
    ignore = true; // 元件卸載或 id 改變時，標記為忽略
  };
}, [id]);
```

## 小結

- 永遠要處理 **Loading** 和 **Error**。
- 使用 `finally` 區塊來確保 Loading 狀態一定會關閉。
- 注意 `useEffect` 中的 **Race Condition**，使用 Cleanup flag 解決。