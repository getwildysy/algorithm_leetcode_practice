# 9.3 伺服器狀態管理：為什麼你需要 TanStack Query (React Query)？

## 本節大綱
- 客戶端狀態 vs. 伺服器狀態
- TanStack Query 解決的問題
- 基本用法
- 實用功能

## 學習目標
- [ ] 理解伺服器狀態的特殊性
- [ ] 掌握 TanStack Query 基本用法
- [ ] 學會快取管理


在 9.2 章節，我們手寫了 `loading`, `error`, `data`, `useEffect`, `Race Condition` 處理... 你不覺得累嗎？
如果每個頁面都要這樣寫，程式碼會充滿重複的 boilerplate。

## 1. Client State vs Server State

我們應該把狀態區分為兩類：
- **Client State**：UI 狀態 (Modal 開關、Input 值)。適合用 `useState`, `Zustand`。
- **Server State**：伺服器資料。**它其實是「快取 (Cache)」**，而不是 State。

**TanStack Query** (前身 React Query) 就是專門管理 Server State 的強大工具。

## 2. 這一行程式碼做了什麼？

```jsx
const { data, isLoading, error } = useQuery({
  queryKey: ['users'], 
  queryFn: fetchUsers
});
```

這一行簡單的 Code 自動幫你處理了：
1. **Loading / Error 狀態管理**。
2. **快取 (Caching)**：5 分鐘內再呼叫同一支 API，直接給快取資料，不發 Request。
3. **自動更新 (Auto Refetch)**：當使用者切換視窗再回來 (Window Focus) 時，自動背景更新資料。
4. **重試機制 (Retries)**：請求失敗自動重試 3 次。
5. **Race Condition**：自動處理掉。

---

## 3. Mutations (修改資料)

Get 資料用 `useQuery`，Create/Update/Delete 資料用 `useMutation`。

```jsx
const mutation = useMutation({
  mutationFn: (newUser) => axios.post('/users', newUser),
  onSuccess: () => {
    // 新增成功後，告訴 QueryClient 'users' 快取髒了，該重抓了
    queryClient.invalidateQueries(['users']);
  }
});

// 使用
<button onClick={() => mutation.mutate({ name: 'Jack' })}>
  Add User
</button>
```

這樣就不用手動去更新 list state，一切交給「重抓」來確保資料與後端同步。

## 小結

- **手寫 fetch + useEffect** 是用來學習原理的。
- 在正式專案中，**強烈建議** 使用 TanStack Query 來取代手寫的 API 呼叫。它能大幅減少程式碼量並提升使用者體驗。
