# 4.1 狀態 vs 變數：為什麼不能直接修改變數？

在學習 React 時，最常問的第一個問題就是：「為什麼我不能直接用 `let` 宣告變數，然後直接改它的值？」

## 1. 變數的命運：隨風而逝

試想我們這樣寫一個計數器：

```jsx
export default function Counter() {
  let count = 0; // 普通變數

  function handleClick() {
    count = count + 1; // 修改變數
    console.log(count); //這裡會印出 1, 2, 3... 但畫面不會變！
  }

  return <button onClick={handleClick}>{count}</button>;
}
```

### 為什麼畫面不動？
1. **React 不知道你改了資料**：修改區域變數不會觸發 React 的 **Re-render (重新渲染)** 機制。
2. **每次渲染都是全新的開始**：就算 React 真的重新渲染了，函式會重新執行，`let count = 0` 這行程式碼會再次執行，變數又被重置回 0。

> [!IMPORTANT]
> **React 的渲染公式**
> `UI = Component(State)`
> 只有當 **State** 改變時，React 才會計算新的 UI 並更新畫面。

---

## 2. State：元件的記憶

**State (狀態)** 是 React 給元件的一個「記憶空間」，它存在於 React 的內部，獨立於函式執行之外。

### State 的特性
1. **持續性**：即使元件重新渲染（函式重新執行），State 的值會保留。
2. **觸發渲染**：當你使用 `setState` 修改它時，React 會知道：「資料變了，我需要更新畫面！」

---

## 3. 心智模型：快照 (Snapshot)

想像 React 元件是一個產生照片（UI）的相機。

1. **初始狀態**：State = 0。相機按下快門，產出一張顯示 "0" 的照片。
2. **使用者點擊**：呼叫 `setCount(1)`。
3. **React 收到通知**：React 說：「好的，下一次拍照我要用 1。」
4. **重新渲染**：React 再次呼叫你的函式，這次它給你的 count 是 1。相機再次快門，產出一張顯示 "1" 的照片。
5. **DOM 更新**：React 比較兩張照片，發現數字變了，於是只更新那個文字節點。

### 比較表格

| 特性 | 普通變數 (let) | 狀態 (state) |
| :--- | :--- | :--- |
| **存放位置** | 函式內部的 Stack | React 內部的記憶體 |
| **生命週期** | 函式執行完即銷毀 | 隨元件共存亡 |
| **修改方式** | 直接賦值 (`=`) | 透過 Setter 函式 |
| **觸發渲染** | ❌ 不會 | ✅ 會 |

## 小結

- **普通變數**就像是寫在沙灘上的字，海浪（Re-render）一來就沒了。
- **State** 就像是刻在石板上的字，能夠在海浪沖刷後依然存在，且每次改變都會讓人注意到。
