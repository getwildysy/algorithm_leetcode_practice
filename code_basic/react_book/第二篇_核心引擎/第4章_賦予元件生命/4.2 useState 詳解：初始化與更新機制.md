# 4.2 useState 詳解：初始化與更新機制

`useState` 是最基礎也最重要的 Hook。掌握它的細節，能讓你避開 80% 的 React Bug。

## 1. 基本語法

```javascript
const [state, setState] = useState(initialState);
```
- **state**: 當前的狀態值。
- **setState**: 用來更新狀態的函式。
- **initialState**: 初始值（只在第一次渲染有效）。

---

## 2. 兩種更新方式

### 2.1 直接更新 (Direct Update)
當新的值**不依賴**舊的值時使用。

```jsx
setIsOpen(true);
setUserName('Alice');
```

### 2.2 函式式更新 (Functional Update)
當新的值**依賴**舊的值時，**強烈建議**使用這種方式。

```jsx
// ❌ 風險寫法
const handleClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  setCount(count + 1);
};
// 結果：只加了 1。因為三次呼叫時，'count' 都是同一個舊值 (例如 0)。

// ✅ 安全寫法
const handleClick = () => {
  setCount(prev => prev + 1); // prev=0, return 1
  setCount(prev => prev + 1); // prev=1, return 2
  setCount(prev => prev + 1); // prev=2, return 3
};
// 結果：加了 3。React 會依序執行這些更新函式。
```

> [!TIP]
> **口訣**：如果你在 `set` 裡面用到原本的 state (`setCount(count + 1)`)，請立刻改成 `setCount(prev => prev + 1)`。

---

## 3. 物件狀態的更新

React 的 State 更新是 **「替換 (Replace)」** 而不是 **「合併 (Merge)」**。這與舊版 Class Component 的 `this.setState` 不同。

```jsx
const [user, setUser] = useState({ name: 'Alice', age: 25 });

// ❌ 錯誤：age 會不見！
setUser({ name: 'Bob' }); 
// 新狀態變成：{ name: 'Bob' }

// ✅ 正確：使用 Spread Operator 保留舊屬性
setUser({ ...user, name: 'Bob' });
// 新狀態變成：{ name: 'Bob', age: 25 }
```

---

## 4. 惰性初始化 (Lazy Initialization)

`initialState` 參數可以用一個函式來傳入。這個函式**只會在初次渲染時執行**。

### 什麼時候用？
當初始值的計算非常昂貴（例如讀取 LocalStorage 或進行複雜運算）時。

```jsx
// ❌ 每次 render 都會執行 JSON.parse (浪費效能)
const [todos, setTodos] = useState(JSON.parse(localStorage.getItem('todos')));

// ✅ 只有第一次 render 會執行
const [todos, setTodos] = useState(() => {
  return JSON.parse(localStorage.getItem('todos'));
});
```

## 小結

- **更新依賴舊值**：請用 `set(prev => prev + 1)`。
- **更新物件**：記得 `...spread` 保留其他屬性。
- **昂貴的初始值**：使用 `useState(() => expensive())`。
