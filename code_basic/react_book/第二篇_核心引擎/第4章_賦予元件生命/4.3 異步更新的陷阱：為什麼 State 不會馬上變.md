# 4.3 異步更新的陷阱：為什麼 State 不會馬上變？

這可能是 React 新手最常撞牆的地方：呼叫了 `setState`，下一行印出來的卻還是舊的值？

## 1. 狀態更新是「非同步」的？

嚴格來說，`setState` 本身不是像 `setTimeout` 那樣的非同步函式，但它的**效果**是非同步的（因為批次處理）。

```jsx
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(1);
  console.log(count); // 😱 還是 0！為什麼？
};
```

### 原因：Snapshot (快照) 模型
在 4.1 節我們提過，State 就像是一張照片。
當你在 `handleClick` 執行時，你手上拿的 `count` 是 **「這一次渲染」** 的快照 (值為 0)。
`setCount(1)` 只是告訴 React：「**下一次渲染**請把 count 變成 1」。
但在**這一次**函式執行結束前，`count` 永遠是 0。

---

## 2. 自動批次更新 (Automatic Batching)

React 18 之後，為了效能，React 會把多個狀態更新「蒐集起來」，最後只重新渲染一次。

```jsx
const handleClick = () => {
  setCount(c => c + 1); // 標記更新
  setFlag(f => !f);     // 標記更新
  setUser({ name: 'A' }); // 標記更新
  // ... 函式結束
  // React: "好，現在一口氣處理這三個並重新渲染一次"
};
```

這就是為什麼你不需要擔心連續呼叫 `setState` 會導致閃爍或效能問題。

---

## 3. 閉包陷阱 (Stale Closure)

當你在 `setTimeout` 或 `useEffect` 中使用 State 時，常常會遇到「抓不到最新值」的問題。

### 發生場景
```jsx
const [count, setCount] = useState(0);

useEffect(() => {
  const timer = setInterval(() => {
    console.log(count); // 永遠印出 0
  }, 1000);
  return () => clearInterval(timer);
}, []); // 空依賴
```

### 為什麼？
`setInterval` 的 callback 函式是在 **第一次渲染** 時建立的。那時候的 `count` 是 0。
這個 closure (閉包) 把 `count = 0` 永遠包在裡面了，它看不見外面世界的變化。

### 解決方案
1. **使用 Ref** (之後章節會教)。
2. **在依賴陣列加入 count** (但這會導致 timer 重啟)。
3. **使用 Functional Update**：

```jsx
// 如果你只是要更新它
setCount(prev => prev + 1); // ✅ prev 永遠是最新的
```

## 小結

- **State 是快照**：在同一次 render 中，State 的值永遠不會變。
- **Batching**：React 會合併更新以提升效能。
- **想要最新值？**：
  1. 如果是用來更新 state，用 `set(prev => ...)`。
  2. 如果是用來邏輯判斷，用 `useEffect` 監聽它。
