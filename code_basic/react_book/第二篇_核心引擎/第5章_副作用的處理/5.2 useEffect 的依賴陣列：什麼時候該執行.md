# 5.2 useEffect 的依賴陣列：什麼時候該執行？

`useEffect` 的第二個參數 —— **依賴陣列 (Dependency Array)**，決定了副作用執行的頻率。

## 1. 三種執行時機

```jsx
// 1. 每次渲染後都執行 (危險！少用)
useEffect(() => {
  console.log('每次都跑');
}); 

// 2. 只在掛載 (Mount) 後執行一次 (常用)
useEffect(() => {
  console.log('只跑一次');
}, []); // 空陣列

// 3. 當特定變數改變時執行 (最常用)
useEffect(() => {
  console.log('count 變了才跑');
}, [count]);
```

---

## 2. 比較機制：Object.is

React 如何判斷 `[count]` 裡面的值有沒有變？它是使用 `Object.is()` 進行**淺層比較 (Shallow Comparison)**。

### 原始型別 (Primitive Types)
字串、數字、布林值。比較的是**值**。
- `1 === 1` (沒變)
- `'a' === 'a'` (沒變)

### 物件/陣列 (Reference Types)
這是一個超級大坑！比較的是**記憶體位置 (Reference)**。

```jsx
// ❌ 陷阱：依賴物件
const options = { color: 'red' }; // 每次 render 都是一個「新的」物件！

useEffect(() => {
  // 這會導致每次 render 都執行 effect
  // 因為 {} !== {}
  doSomething(options);
}, [options]);
```

> [!CAUTION]
> **無限迴圈警報**：如果你的 effect 會更新 state，而該 state 又導致重新渲染產生新的物件依賴... BOOM！無限迴圈。

### 解決方案
1. **移到 Effect 內部**：如果 options 不需要被其他人用，直接宣告在 effect 裡面。
2. **使用 useMemo**：快取這個物件 (之後章節會教)。
3. **讀取原始值**：依賴 `options.color` 而不是整個 `options` 物件。

---

## 3. ESLint 是你的好朋友

React 官方提供了 `eslint-plugin-react-hooks`。它會檢查你的依賴陣列是否誠實。

**誠實原則**：所有在 Effect 內部用到的響應式數值 (Props, State, 函式內的變數)，都**必須**列在依賴陣列中。

- 如果你「欺騙」React (少寫依賴)，可能會導致邏輯錯誤（讀到舊的值）。
- 如果你覺得「列出來會導致無限迴圈」，那通常代表你的程式碼結構有問題，而不是 React 規則有問題。

## 小結

- **空陣列 `[]`**：只跑一次。
- **有依賴 `[a, b]`**：當 a 或 b 改變時跑。
- **物件依賴**：小心 Reference 改變導致的意外執行。
- **誠實列出依賴**：不要為了不想跑 effect 而隱瞞依賴。
