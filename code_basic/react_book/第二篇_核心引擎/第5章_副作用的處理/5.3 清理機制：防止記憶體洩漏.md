# 5.3 清理機制 (Cleanup Function)：防止記憶體洩漏

`useEffect` 也可以返回一個函式，我們稱之為 **Cleanup Function (清理函式)**。這是 React 讓你有機會在 component 消失前「收拾善後」的地方。

## 1. 生命週期圖解

當元件重新渲染時：

1. **Unmount (Previous)**：先執行上一輪 Effect 留下的清理函式。
2. **Mount (Current)**：執行這一輪的 Effect。

```javascript
useEffect(() => {
  console.log('Effect 執行');
  
  return () => {
    console.log('Cleanup 執行');
  };
}, [id]); // 假設 id 從 1 變成 2

// 流程：
// 1. (id=1) Effect 執行
// -- 變更發生 --
// 2. (id=1) Cleanup 執行 <--- 先清理舊的！
// 3. (id=2) Effect 執行
```

---

## 2. 常見應用場景

### 2.1 事件監聽 (Event Listeners)
如果你不移除，component 若被銷毀多次，就會累積成千上萬個 listener，最後把瀏覽器卡死。

```jsx
useEffect(() => {
  const handleScroll = () => console.log(window.scrollY);
  window.addEventListener('scroll', handleScroll);

  // ✅ 記得移除！
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

### 2.2 計時器 (Intervals / Timeouts)

```jsx
useEffect(() => {
  const id = setInterval(() => {
    console.log('Tick');
  }, 1000);

  // ✅ 記得清除！
  return () => clearInterval(id);
}, []);
```

### 2.3 避免 Race Condition (資料請求)
當使用者快速切換 ID（例如快速點擊上一頁/下一頁），如果不處理，舊的請求可能會覆蓋新的請求。

```jsx
useEffect(() => {
  let ignore = false; // 旗標

  fetch(`/api/user/${id}`)
    .then(res => res.json())
    .then(data => {
      if (!ignore) { // 只有在沒被清理時才設定值
        setUser(data);
      }
    });

  return () => {
    ignore = true; // 標記為「已忽略」
  };
}, [id]);
```

---

## 3. Strict Mode：為什麼 Effect 跑兩次？

在開發模式 (Development Mode) 下，React 18 的 Strict Mode 會故意「Mount -> Unmount -> Mount」你的 component 一次。
這是為了**幫你檢查**有沒有正確實作清理函式。

如果你發現 Effect 跑了兩次：
1. **別擔心**，Production 模式只會跑一次。
2. **檢查 Cleanup**，確保你的 Effect 可以被重複掛載/卸載而不會出錯。

## 小結

- **有借有還**：有訂閱就要取消，有計時又要清除。
- **清理時機**：在 Component 卸載時，或依賴改變導致 Effect 重跑之前。
- **Race Condition**：使用 boolean flag 來忽略過期的 API 回應。
