# 5.4 練習題與自我測驗

## 觀念測驗 (Multiple Choice)

### Q1: [Effect] 下列關於 `useEffect` 的依賴陣列，何者正確？
1. 若不傳入第二個參數 (省略陣列)，Effect 只會在掛載時執行一次。
2. 若傳入空陣列 `[]`，Effect 會在每次渲染後執行。
3. 若省略依賴陣列，Effect 會在「每次渲染後」都執行。
4. 依賴陣列中的變數只要是物件，React 就會深入比較內容是否改變。

<details>
<summary>點擊查看答案</summary>
**答案：3**
<br>
**解析**：省略陣列代表「不依賴任何特定變數」，所以每次 Render 完都會跑。空陣列 `[]` 才是只跑一次。
</details>

---

### Q2: [Cleanup] 清理函式 (Cleanup Function) 何時會執行？
1. 只有在 Component 被完全移除 (Unmount) 時。
2. 在瀏覽器關閉分頁時。
3. 在下一次 Effect 執行之前，以及 Component 卸載時。
4. 每當 State 改變時都會執行。

<details>
<summary>點擊查看答案</summary>
**答案：3**
<br>
**解析**：這是為了確保不會有舊的副作用殘留干擾新的副作用。
</details>

---

### Q3: [Ref] 為什麼在 Effect 中依賴物件型別的變數很危險？
```jsx
const config = { theme: 'dark' };
useEffect(() => ..., [config]);
```
1. 因為 React 不支援物件。
2. 因為每次 Render 時 `config` 都是一個全新的記憶體參考 (Reference)，導致無限迴圈或過度執行。
3. 因為物件佔用太多記憶體。

<details>
<summary>點擊查看答案</summary>
**答案：2**
<br>
**解析**：React 使用 `Object.is` (淺層比較)，`{}` 不等於 `{}`。
</details>

---

## 程式碼挑戰 (Coding Challenges)

### 挑戰 1：視窗寬度追蹤器 (Memory Leak Fix)
**情境**：這段程式碼有嚴重的記憶體洩漏問題，請修復它。
```jsx
useEffect(() => {
  const onResize = () => console.log(window.innerWidth);
  window.addEventListener('resize', onResize);
  // 提示：缺少了什麼？
}, []);
```

### 挑戰 2：自動對焦輸入框
**目標**：建立一個 Input 元件，當它被渲染到畫面上時，自動取得焦點 (Focus)。
**提示**：使用 `useEffect` 配合 `useRef` (或直接操作 DOM API `document.getElementById`，雖然不推薦)。

### 挑戰 3：倒數計時器 (Stale Closure)
**目標**：實作一個倒數 10 秒的計時器。
**限制**：使用 `setInterval`。
**挑戰**：確保每一秒數字都能正確減少，不會卡在 9。
```jsx
useEffect(() => {
  const id = setInterval(() => {
    // 這裡該怎麼寫？
    setCount(c => c - 1); 
  }, 1000);
  return () => clearInterval(id);
}, []);
```
