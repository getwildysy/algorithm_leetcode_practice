# 6.2 受控元件：雙向綁定的實作

在 HTML 中，表單元素 (如 input, select) 通常會自己維護狀態。
但在 React 中，我們習慣把所有狀態都交給 **State** 管理，這就叫做 **Controlled Component (受控元件)**。

## 1. 單一輸入框 (Single Input)

```jsx
const [text, setText] = useState('');

<input 
  value={text}                 // 1. 資料來源是 State
  onChange={e => setText(e.target.value)} // 2. 修改時通知 State
/>
```
這就是所謂的「雙向綁定」：
- **State -> Input**：透過 `value` prop。
- **Input -> State**：透過 `onChange` prop。

---

## 2. 多個輸入框的處理 (Multiple Inputs)

如果不想要為了每個欄位都寫一個 `useState` 和 `handler`，我們可以用一個物件來管理。

```jsx
const [form, setForm] = useState({
  username: '',
  email: '',
  password: ''
});

const handleChange = (e) => {
  const { name, value } = e.target;
  
  // 使用 Computed Property Name語法 [name]
  setForm({
    ...form,       // 記得保留舊的欄位
    [name]: value  // 更新變動的欄位
  });
};

return (
  <form>
    <input name="username" value={form.username} onChange={handleChange} />
    <input name="email" value={form.email} onChange={handleChange} />
  </form>
);
```

---

## 3. 各種表單元素的陷阱

### Textarea
在 React 中，`<textarea>` 不再使用 content，而是使用 `value` 屬性。
```jsx
<textarea value={bio} onChange={...} />
```

### Checkbox
它使用的是 `checked` 而不是 `value`！
```jsx
// ❌ 錯誤
<input type="checkbox" value={isChecked} />

// ✅ 正確
<input 
  type="checkbox" 
  checked={isChecked} 
  onChange={e => setIsChecked(e.target.checked)} 
/>
```

### Select
直接在 `<select>` 標籤上設 `value`，不需要去控制 `<option>` 的 selected 屬性。
```jsx
<select value={city} onChange={e => setCity(e.target.value)}>
  <option value="tp">Taipei</option>
  <option value="ny">New York</option>
</select>
```

## 小結

- **受控元件**：React State 是唯一的「真理來源 (Source of Truth)」。
- **物件狀態**：善用 `[e.target.name]` 來統一處理多欄位表單。
- **Checkbox**：記得它是看 `checked` 屬性。
